<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker部署RabbitMQ集群和Haproxy负载均衡和高可用(1)</title>
    <url>/2019/08/28/Docker%E9%83%A8%E7%BD%B2RabbitMQ%E9%9B%86%E7%BE%A4%E5%92%8CHaproxy%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8-1/</url>
    <content><![CDATA[<h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull rabbitmq:3-management</span><br><span class="line"></span><br><span class="line">docker pull rabbitmq:3-management</span><br></pre></td></tr></table></figure>

<h3 id="link-连接-仅集群，不代理"><a href="#link-连接-仅集群，不代理" class="headerlink" title="link 连接(仅集群，不代理)"></a>link 连接(仅集群，不代理)</h3><p>node_0</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --hostname node_0_rabbit --name node_0_rabbit -e RABBITMQ_DEFAULT_USER=your username -e RABBITMQ_DEFAULT_PASS=yous pword -e RABBITMQ_ERLANG_COOKIE=&#x27;rabbitcookie&#x27; -p 15672:15672 -p 5672:5672 rabbitmq:3-management</span><br></pre></td></tr></table></figure>

<p>node_1</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --hostname node_1_rabbit --name node_1_rabbit --link node_0_rabbit:node_0_rabbit -e RABBITMQ_ERLANG_COOKIE=&#x27;rabbitcookie&#x27; -e RABBITMQ_DEFAULT_USER=your username -e RABBITMQ_DEFAULT_PASS=yous pword -p 15673:15672 -p 5673:5672 rabbitmq:3-management</span><br></pre></td></tr></table></figure>

<p>node_2</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --hostname node_2_rabbit --name node_2_rabbit --link node_0_rabbit:node_0_rabbit --link node_1_rabbit:node_1_rabbit -e RABBITMQ_ERLANG_COOKIE=&#x27;rabbitcookie&#x27; -e RABBITMQ_DEFAULT_USER=your username -e RABBITMQ_DEFAULT_PASS=yous pword -p 15674:15672 -p 5674:5672 rabbitmq:3-management</span><br></pre></td></tr></table></figure>

<h3 id="network-连接"><a href="#network-连接" class="headerlink" title="network 连接"></a>network 连接</h3><p>内网ip一览</p>
<ul>
<li>172.100.100.3 - node_0_rabbit</li>
<li>172.100.100.4 - node_1_rabbit</li>
<li>172.100.100.5 - node_2_rabbit</li>
<li>172.100.100.6 - haproxy_0</li>
<li>172.100.100.7 - haproxy_1</li>
</ul>
<p>创建网卡</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network create --subnet=172.100.100.0/24 rabbit_net</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：docker rabbitmq需要节点设置erlang cookie，节点之间需要一致。服务器则需要拷贝相关.erlang.cookie文件（好像是这个）</p>
</blockquote>
<p>node_0</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --hostname node_0_rabbit \</span><br><span class="line">--name node_0_rabbit \</span><br><span class="line">--net=rabbit_net \</span><br><span class="line">--ip=172.100.100.3 \</span><br><span class="line">-e RABBITMQ_DEFAULT_USER=your username \</span><br><span class="line">-e RABBITMQ_DEFAULT_PASS=yous pword \</span><br><span class="line">-e RABBITMQ_ERLANG_COOKIE=&#x27;rabbitcookie&#x27; \</span><br><span class="line">-p 15672:15672 \</span><br><span class="line">-p 5672:5672 \</span><br><span class="line">rabbitmq:3-management</span><br></pre></td></tr></table></figure>

<p>node_1</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --hostname node_1_rabbit \</span><br><span class="line">--name node_1_rabbit \</span><br><span class="line">--net=rabbit_net \</span><br><span class="line">--ip=172.100.100.4 \</span><br><span class="line">-e RABBITMQ_DEFAULT_USER=your username \</span><br><span class="line">-e RABBITMQ_DEFAULT_PASS=yous pword \</span><br><span class="line">-e RABBITMQ_ERLANG_COOKIE=&#x27;rabbitcookie&#x27; \</span><br><span class="line">-p 15673:15672 \</span><br><span class="line">-p 5673:5672 \</span><br><span class="line">rabbitmq:3-management</span><br></pre></td></tr></table></figure>

<p>node_2</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --hostname node_2_rabbit \</span><br><span class="line">--name node_2_rabbit \</span><br><span class="line">--net=rabbit_net \</span><br><span class="line">--ip=172.100.100.5 \</span><br><span class="line">-e RABBITMQ_DEFAULT_USER=your username \</span><br><span class="line">-e RABBITMQ_DEFAULT_PASS=yous pword \</span><br><span class="line">-e RABBITMQ_ERLANG_COOKIE=&#x27;rabbitcookie&#x27; \</span><br><span class="line">-p 15674:15672 \</span><br><span class="line">-p 5674:5672 \</span><br><span class="line">rabbitmq:3-management</span><br></pre></td></tr></table></figure>

<p>haproxy_0</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">5670 web监控 http://your ip address:5670/rabbitmq-stats</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">5671 集群端口</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">关于配置</span></span><br><span class="line">docker run -d --hostname haproxy_0 \</span><br><span class="line">--name haproxy_0 \</span><br><span class="line">-p 5670-5671:5670-5671 \</span><br><span class="line">-v /home/haproxy/haproxy.cfg:/usr/local/etc/haproxy/haproxy.cfg \</span><br><span class="line">--ip=172.100.100.6 \</span><br><span class="line">--net=rabbit_net haproxy</span><br></pre></td></tr></table></figure>

<p>haproxy_1 同理 后面高可用备用</p>
<p>haproxy.cfg</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">global</span><br><span class="line">  maxconn 5120</span><br><span class="line">  log 127.0.0.1 local0 info        #[err warning info debug]</span><br><span class="line">  chroot /usr/local/sbin           #chroot运行的路径</span><br><span class="line">  daemon                           #以后台形式运行haproxy</span><br><span class="line">  nbproc 20</span><br><span class="line">  pidfile /var/run/haproxy.pid     #haproxy的pid存放路径,启动进程的用户必须有权限访问此文件</span><br><span class="line">defaults</span><br><span class="line">  log global</span><br><span class="line">  mode tcp                         #所处理的类别 (#7层 http;4层tcp  )</span><br><span class="line">  maxconn 2000                     #最大连接数</span><br><span class="line">  option dontlognull               #不记录健康检查的日志信息</span><br><span class="line">  option redispatch                #serverId对应的服务器挂掉后,强制定向到其他健康的服务器</span><br><span class="line">  option tcplog</span><br><span class="line"><span class="meta">  #</span><span class="language-bash">stats refresh 30                <span class="comment">#统计页面刷新间隔</span></span></span><br><span class="line">  retries 3                        #3次连接失败就认为服务不可用，也可以通过后面设置</span><br><span class="line"><span class="meta">  #</span><span class="language-bash">balance roundrobin              <span class="comment">#默认的负载均衡的方式,轮询方式</span></span></span><br><span class="line"><span class="meta">  #</span><span class="language-bash">balance <span class="built_in">source</span>                  <span class="comment">#默认的负载均衡的方式,类似nginx的ip_hash</span></span></span><br><span class="line"><span class="meta">  #</span><span class="language-bash">balance leastconn               <span class="comment">#默认的负载均衡的方式,最小连接</span></span></span><br><span class="line"><span class="meta">  #</span><span class="language-bash"><span class="built_in">timeout</span> connect 5000            <span class="comment">#连接超时</span></span></span><br><span class="line"><span class="meta">  #</span><span class="language-bash"><span class="built_in">timeout</span> client 50000            <span class="comment">#客户端超时</span></span></span><br><span class="line"><span class="meta">  #</span><span class="language-bash"><span class="built_in">timeout</span> server 50000            <span class="comment">#服务器超时</span></span></span><br><span class="line"><span class="meta">  #</span><span class="language-bash"><span class="built_in">timeout</span> check 2000              <span class="comment">#心跳检测超时</span></span></span><br><span class="line">  contimeout 5s</span><br><span class="line">  clitimeout 60s</span><br><span class="line">  srvtimeout 15s</span><br><span class="line"><span class="meta">#</span><span class="language-bash">配置haproxy web监控</span></span><br><span class="line">listen stats</span><br><span class="line">  bind 0.0.0.0:5670</span><br><span class="line">  mode http</span><br><span class="line">  option httplog</span><br><span class="line">  stats enable</span><br><span class="line">  stats uri /rabbitmq-stats        #统计页面url</span><br><span class="line">  stats refresh 5s</span><br><span class="line">listen rabbitmq_cluster</span><br><span class="line">  bind 0.0.0.0:5671</span><br><span class="line">  option tcplog</span><br><span class="line">  mode tcp</span><br><span class="line"><span class="meta">  #</span><span class="language-bash"><span class="built_in">timeout</span> client  3h</span></span><br><span class="line"><span class="meta">  #</span><span class="language-bash"><span class="built_in">timeout</span> server  3h</span></span><br><span class="line"><span class="meta">  #</span><span class="language-bash">option          clitcpka</span></span><br><span class="line">  balance roundrobin               #负载均衡算法（#banlance roundrobin 轮询，balance source 保存session值，支持static-rr，leastconn，first，uri等参数）</span><br><span class="line"><span class="meta">  #</span><span class="language-bash">balance url_param userid</span></span><br><span class="line"><span class="meta">  #</span><span class="language-bash">balance url_param session_id check_post 64</span></span><br><span class="line"><span class="meta">  #</span><span class="language-bash">balance hdr(User-Agent)</span></span><br><span class="line"><span class="meta">  #</span><span class="language-bash">balance hdr(host)</span></span><br><span class="line"><span class="meta">  #</span><span class="language-bash">balance hdr(Host) use_domain_only</span></span><br><span class="line"><span class="meta">  #</span><span class="language-bash">balance rdp-cookie</span></span><br><span class="line"><span class="meta">  #</span><span class="language-bash">balance leastconn</span></span><br><span class="line"><span class="meta">  #</span><span class="language-bash">balance <span class="built_in">source</span> //ip</span></span><br><span class="line">  server node_0_rabbit 172.100.100.3:5672 check inter 5s rise 2 fall 2   #check inter 2000 是检测心跳频率，rise 2是2次正确认为服务器可用，fall 3是3次失败认为服务器不可用</span><br><span class="line">  server node_1_rabbit 172.100.100.4:5672 check inter 5s rise 2 fall 2</span><br><span class="line">  server node_2_rabbit 172.100.100.5:5672 check inter 5s rise 2 fall 2</span><br></pre></td></tr></table></figure>

<h3 id="设置mq集群"><a href="#设置mq集群" class="headerlink" title="设置mq集群"></a>设置mq集群</h3><p>使用rabbitmqctl</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">node_0</span></span><br><span class="line">docker exec -it node_0_rabbit bash</span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl start_app</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">node_1 node_2 (join_cluster --ram 以内存的方式加入，默认disc)</span></span><br><span class="line">docker exec -it node_1（2）_rabbit bash</span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl join_cluster rabbit@node_0_rabbit</span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure>

<h3 id="开启集群镜像模式"><a href="#开启集群镜像模式" class="headerlink" title="开启集群镜像模式"></a>开启集群镜像模式</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">任何rabbitmq节点</span></span><br><span class="line">rabbitmqctl set_policy ha-all &quot;^&quot; &#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><blockquote>
<ul>
<li><a href="https://www.runoob.com/docker/docker-command-manual.html">docker 命令大全</a></li>
<li><a href="https://www.rabbitmq.com/clustering.html">Clustering Guide - 官方文档</a> //英语，关键翻译就可以了</li>
<li><a href="https://hub.docker.com/_/haproxy?tab=description">haproxy docker hub</a> //看描述，如何执行</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Skill</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>RabbitMQ</tag>
        <tag>Haproxy</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Spring 杂记 - BaseService</title>
    <url>/2019/06/26/Java-Spring-%E6%9D%82%E8%AE%B0-BaseService/</url>
    <content><![CDATA[<p>项目中缓存服务CacheService继承的BaseService抽象类源码学习，其他服务层实现类在同包名下也有在使用(CacheService继承BaseService，其他不同模块相同包名的，继承CacheService)。</p>
<hr>
<h2 id="Golang、前端所没有的-…-回顾面向对象"><a href="#Golang、前端所没有的-…-回顾面向对象" class="headerlink" title="Golang、前端所没有的 …(回顾面向对象)"></a>Golang、前端所没有的 …(回顾面向对象)</h2><blockquote>
<h3 id="Java-抽象类"><a href="#Java-抽象类" class="headerlink" title="Java 抽象类"></a>Java 抽象类</h3><p>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。<br><br>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。<br><br>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。<br><br>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。<br><br>在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p>
</blockquote>
<h4 id="BaseService"><a href="#BaseService" class="headerlink" title="BaseService"></a>BaseService</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.xxx.appserver.commons.support.JsonUtility;</span><br><span class="line"><span class="keyword">import</span> com.xxx.appserver.commons.support.SpringContextUtility;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.JsonNode;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseService</span>&lt;S&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> S proxy;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">protected</span> SpringContextUtility springContextUtility;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被@PostConstruct修饰的方法会在构造函数之后，init()方法之前运行。</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">post</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Class&lt;?&gt;它是个通配泛型，?可以代表任何类型</span></span><br><span class="line">        <span class="comment">// 通过getInterfaces()获取接口信息(eg:moe.test.ITest)</span></span><br><span class="line">        Class&lt;?&gt;[] interfaces = <span class="built_in">this</span>.getClass().getInterfaces();</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> == interfaces || interfaces.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        proxy = (S) springContextUtility.getBean(interfaces[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> JsonNode <span class="title function_">getNodeList</span><span class="params">(String json)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">JsonNode</span> <span class="variable">node</span> <span class="operator">=</span> JsonUtility.readTree(json);</span><br><span class="line">        <span class="keyword">return</span> node.get(<span class="string">&quot;list&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>泛型类：在编译器，是无法知道S具体是什么类型，只有在运行时才会真正根据类型来构造和分配内存。(项目中一般传的是服务接口)<br>声明泛型proxy，通过post方法从Bean中获取到对应接口信息的接口实现，即在继承使用的类中可以通过proxy调用其他服务的方法，就是使用到SpringContextUtility，下面分析。</p>
</blockquote>
<h4 id="SpringContextUtility"><a href="#SpringContextUtility" class="headerlink" title="SpringContextUtility"></a>SpringContextUtility</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @Component注解表明一个类会作为组件类，并告知Spring要为这个类创建bean</span></span><br><span class="line"><span class="comment">// 和@Bean目的是一样的，都是注册bean到Spring容器中。</span></span><br><span class="line"><span class="comment">// @Component（@Controller、@Service、@Repository）通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中。</span></span><br><span class="line"><span class="comment">// 而@Bean注解通常是我们在标有该注解的方法中定义产生这个bean的逻辑。</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringContextUtility</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext application)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        applicationContext = application;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">return</span> applicationContext.getBean(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(Class&lt;T&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> applicationContext.getBean(clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建个类实现ApplicationContextAware工具类，可以通过其它类引用它以操作spring容器及其中的Bean实例。<br><br>Spring容器会检测容器中的所有Bean，如果发现某个Bean实现了ApplicationContextAware接口，Spring容器会在创建该Bean之后，自动调用该Bean的setApplicationContextAware()方法，调用该方法时，会将容器本身作为参数传给该方法——该方法中的实现部分将Spring传入的参数（容器本身）赋给该类对象的applicationContext实例变量，因此接下来可以通过该applicationContext实例变量来访问容器本身。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>还是登陆方法吧</p>
<h4 id="UserServiceImpl"><a href="#UserServiceImpl" class="headerlink" title="UserServiceImpl"></a>UserServiceImpl</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@CacheConfigList(&#123;</span></span><br><span class="line"><span class="meta">        @CacheConfiguration(nameSpace = CacheKey.GAME_CATCH_USER, expTime = 172800)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">CacheService</span>&lt;IUserService&gt; <span class="keyword">implements</span> <span class="title class_">IUserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDto <span class="title function_">login</span><span class="params">(String code, String encryptedData, String iv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="type">UserDto</span> <span class="variable">user</span> <span class="operator">=</span> proxy.queryUserByUid(wxUser.getOpenId());</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//缓存用户</span></span><br><span class="line">        proxy.saveUserByUid(user);</span><br><span class="line">        log.info(<span class="string">&quot;用户登录:&quot;</span> + user);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这个实现类继承了CacheService，泛型传的是IUserService接口，通过proxy我们就可以调到接口实现的方法了，下面是IUserService接口</p>
<h4 id="IUserService"><a href="#IUserService" class="headerlink" title="IUserService"></a>IUserService</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 登录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    UserDto <span class="title function_">login</span><span class="params">(String code, String encryptedData, String iv)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *缓存用户数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userDto</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    UserDto <span class="title function_">saveUserByUid</span><span class="params">(UserDto userDto)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uid</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    UserDto <span class="title function_">queryUserByUid</span><span class="params">(String uid)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Skill</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 微信登陆逻辑记录</title>
    <url>/2019/06/24/Java-%E5%BE%AE%E4%BF%A1%E7%99%BB%E9%99%86%E9%80%BB%E8%BE%91%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="Java-微信登陆"><a href="#Java-微信登陆" class="headerlink" title="Java 微信登陆"></a>Java 微信登陆</h3><p>code、encryptedData、iv：<br>需要前端通过wx.login获取code，wx.getUserInfo获取encryptedData用户数据加密、iv偏移向量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /game-catch/ ... /com.xxxx.appserver/WeixinController.java</span></span><br><span class="line"><span class="keyword">public</span> UserDto <span class="title function_">login</span><span class="params">(String code, String encryptedData, String iv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// code、encryptedData、iv</span></span><br><span class="line">    <span class="comment">// 需要前端通过wx.login获取code，wx.getUserInfo获取encryptedData用户数据加密、iv偏移向量</span></span><br><span class="line">    <span class="type">WxSessionModel</span> <span class="variable">wxSession</span> <span class="operator">=</span> wxClientApi.getSessionKey(WxSessionModel.class, code);</span><br><span class="line">    <span class="type">WxUserModel</span> <span class="variable">wxUser</span> <span class="operator">=</span> wxClientApi.getUserInfo(WxUserModel.class, wxSession.getSession_key(), encryptedData, iv);</span><br><span class="line">    <span class="type">UserDto</span> <span class="variable">user</span> <span class="operator">=</span> proxy.queryUserByUid(wxUser.getOpenId());</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">        user = registUser(wxUser);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        user.setName(wxUser.getNickName());</span><br><span class="line">        user.setAvatarUrl(wxUser.getAvatarUrl());</span><br><span class="line">        user.setSex(wxUser.getGender());</span><br><span class="line">        reactor.notify(<span class="string">&quot;updateUserHandler&quot;</span>, Event.wrap(user));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//缓存用户</span></span><br><span class="line">    proxy.saveUserByUid(user);</span><br><span class="line">    log.info(<span class="string">&quot;用户登录:&quot;</span> + user);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="getSessionKey-Class-resultClass-String-code"><a href="#getSessionKey-Class-resultClass-String-code" class="headerlink" title="getSessionKey(Class resultClass, String code)"></a>getSessionKey(Class<T> resultClass, String code)</h5><p>请求地址：api.weixin.qq.com/sns/jscode2session<br><br>根据前端传的code请求微信接口获取session<br><br>checkCode(HttpResponse response),对请求微信接口的结果做异常处理，有errcode!=0和，httpcode!=200的时候抛异常<br></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getSessionKey</span><span class="params">(Class&lt;T&gt; resultClass, String code)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// makeHttpsUrl方法根据传入的字符串去application-local.yml获取配置信息,如下yml配置</span></span><br><span class="line">    <span class="type">HttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpRequest</span>(makeHttpsUrl(<span class="string">&quot;sessionPath&quot;</span>));</span><br><span class="line">    request.addParameter(<span class="string">&quot;appid&quot;</span>, getProperties(<span class="string">&quot;AppID&quot;</span>));</span><br><span class="line">    request.addParameter(<span class="string">&quot;secret&quot;</span>, getProperties(<span class="string">&quot;AppSecret&quot;</span>));</span><br><span class="line">    request.addParameter(<span class="string">&quot;js_code&quot;</span>, code);</span><br><span class="line">    request.addParameter(<span class="string">&quot;grant_type&quot;</span>, <span class="string">&quot;authorization_code&quot;</span>);</span><br><span class="line">    <span class="type">HttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> clientManager.execute(request);</span><br><span class="line">    checkCode(response);</span><br><span class="line">    <span class="keyword">return</span> JsonUtility.toObject(response.getContentString(), resultClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终json反序列化，返回这样的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WxSessionModel</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer errcode;         <span class="comment">// 返回码</span></span><br><span class="line">    <span class="keyword">private</span> String errmsg;           <span class="comment">// 返回错误信息</span></span><br><span class="line">    <span class="keyword">private</span> String openid;          <span class="comment">// 用户唯一标识</span></span><br><span class="line">    <span class="keyword">private</span> String session_key;     <span class="comment">// 会话密钥</span></span><br><span class="line">    <span class="keyword">private</span> String unionid;      <span class="comment">// 用户在开放平台的唯一标识符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>application-local.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">http:</span></span><br><span class="line">   <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">   <span class="attr">time-out-socket:</span> <span class="number">5000</span></span><br><span class="line">   <span class="attr">time-out-connection:</span> <span class="number">2000</span></span><br><span class="line">   <span class="attr">time-out-request-connection:</span> <span class="number">5000</span></span><br><span class="line">   <span class="attr">retry-number:</span> <span class="number">2</span></span><br><span class="line">   <span class="attr">max-total:</span> <span class="number">500</span></span><br><span class="line">   <span class="attr">client-properties:</span></span><br><span class="line">     <span class="attr">weixin:</span></span><br><span class="line">       <span class="attr">host:</span> <span class="string">api.weixin.qq.com</span></span><br><span class="line">       <span class="attr">max-pre-route:</span> <span class="number">100</span></span><br><span class="line">       <span class="attr">url-map:</span></span><br><span class="line">         <span class="attr">sessionPath:</span> <span class="string">/sns/jscode2session</span></span><br><span class="line">         <span class="attr">TokenPath:</span> <span class="string">/cgi-bin/token</span></span><br><span class="line">         <span class="attr">ScoreStoragePath:</span> <span class="string">/wxa/set_user_storage</span></span><br><span class="line">         <span class="attr">AppID:</span> <span class="string">xxxxxxxxxxx</span></span><br><span class="line">         <span class="attr">AppSecret:</span> <span class="string">xxxxxx</span></span><br></pre></td></tr></table></figure>
<h5 id="getUserInfo-Class-resultClass-String-sessionKey-String-encryptedData-String-iv"><a href="#getUserInfo-Class-resultClass-String-sessionKey-String-encryptedData-String-iv" class="headerlink" title="getUserInfo(Class resultClass, String sessionKey, String encryptedData, String iv)"></a>getUserInfo(Class<T> resultClass, String sessionKey, String encryptedData, String iv)</h5><p>解密前端传入的encryptedData加密用户信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getUserInfo</span><span class="params">(Class&lt;T&gt; resultClass, String sessionKey, String encryptedData, String iv)</span> &#123;</span><br><span class="line">    <span class="comment">// 被加密的数据</span></span><br><span class="line">    <span class="type">byte</span>[] dataByte = Base64.decode(encryptedData);</span><br><span class="line">    <span class="comment">// 加密秘钥</span></span><br><span class="line">    <span class="type">byte</span>[] keyByte = Base64.decode(sessionKey);</span><br><span class="line">    <span class="comment">// 偏移量</span></span><br><span class="line">    <span class="type">byte</span>[] ivByte = Base64.decode(iv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果密钥不足16位，那么就补足.  这个if 中的内容很重要</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">if</span> (keyByte.length % base != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">groups</span> <span class="operator">=</span> keyByte.length / base + (keyByte.length % base != <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            <span class="type">byte</span>[] temp = <span class="keyword">new</span> <span class="title class_">byte</span>[groups * base];</span><br><span class="line">            Arrays.fill(temp, (<span class="type">byte</span>) <span class="number">0</span>);</span><br><span class="line">            System.arraycopy(keyByte, <span class="number">0</span>, temp, <span class="number">0</span>, keyByte.length);</span><br><span class="line">            keyByte = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        Security.addProvider(<span class="keyword">new</span> <span class="title class_">BouncyCastleProvider</span>());</span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;AES/CBC/PKCS7Padding&quot;</span>, <span class="string">&quot;BC&quot;</span>);</span><br><span class="line">        <span class="type">SecretKeySpec</span> <span class="variable">spec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(keyByte, <span class="string">&quot;AES&quot;</span>);</span><br><span class="line">        <span class="type">AlgorithmParameters</span> <span class="variable">parameters</span> <span class="operator">=</span> AlgorithmParameters.getInstance(<span class="string">&quot;AES&quot;</span>);</span><br><span class="line">        parameters.init(<span class="keyword">new</span> <span class="title class_">IvParameterSpec</span>(ivByte));</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, spec, parameters);<span class="comment">// 初始化</span></span><br><span class="line">        <span class="type">byte</span>[] resultByte = cipher.doFinal(dataByte);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != resultByte &amp;&amp; resultByte.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(resultByte, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> JsonUtility.toObject(result, resultClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解密后，返回这样的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WxUserModel</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String nickName;            <span class="comment">// 用户昵称</span></span><br><span class="line">    <span class="keyword">private</span> String openId;              <span class="comment">// openId</span></span><br><span class="line">    <span class="keyword">private</span> String unionId;             <span class="comment">// unionId</span></span><br><span class="line">    <span class="keyword">private</span> String avatarUrl;           <span class="comment">// 头像地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">gender</span> <span class="operator">=</span> Constant.Gender.Nomal.ordinal();            <span class="comment">// 性别</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共枚举取，详情查看Constant</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 性别</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Gender</span> &#123;</span><br><span class="line">    Nomal,      <span class="comment">//未知</span></span><br><span class="line">    Man,        <span class="comment">//男</span></span><br><span class="line">    Woman       <span class="comment">//女</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>主要是没有做过获取微信用户信息这一块，后面的操作就是业务逻辑，存在我们自己的数据库了，唯一标识就是wx的openId</p>
]]></content>
      <categories>
        <category>Skill</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Reactor使用(1)</title>
    <url>/2019/07/25/Spring-Reactor%E4%BD%BF%E7%94%A8-1/</url>
    <content><![CDATA[<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>不做说明，仅记录代码及使用</p>
<h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><p>src/…/reactor/config/ReactorConfig.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class ReactorConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    Environment env() &#123;</span><br><span class="line">        return new Environment();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Primary</span><br><span class="line">    Reactor pool(Environment env) &#123;</span><br><span class="line">        return Reactors.reactor()</span><br><span class="line">                    .env(env)</span><br><span class="line">                    .dispatcher(Environment.THREAD_POOL)</span><br><span class="line">                    .get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    Reactor loop(Environment env) &#123;</span><br><span class="line">        return Reactors.reactor()</span><br><span class="line">                    .env(env)</span><br><span class="line">                    .dispatcher(Environment.EVENT_LOOP)</span><br><span class="line">                    .get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>src/…/reactor/ReactorListener.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class ReactorListener implements InitializingBean &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    Reactor reactor;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    UserHandler userHandler;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        reactor.on($(&quot;userHandler&quot;), userHandler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>src/…/reactor/handler/UserHandler.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class UserHandler implements Consumer&lt;Event&lt;UserDto&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void accept(Event&lt;UserDto&gt; userDtoEvent) &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            UserDto user = userDtoEvent.getData();</span><br><span class="line">            user = userMapper.getUser(user.getId());</span><br><span class="line">            log.info(&quot;in userHandler: user=&#123;&#125;&quot;, user);</span><br><span class="line">        &#125; catch(Exception e) &#123;</span><br><span class="line">            log.error(String.valueOf(e));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>controller</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    Reactor reactor;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    IUserService userService;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/get&quot;)</span><br><span class="line">    public UserDto getUser(Integer uid) &#123;</span><br><span class="line"></span><br><span class="line">        UserDto userDto = new UserDto();</span><br><span class="line">        userDto.setId(uid);</span><br><span class="line"></span><br><span class="line">        reactor.notify(&quot;userHandler&quot;, Event.wrap(userDto));</span><br><span class="line">        return userService.getUser(uid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Skill</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Reactor</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Reactor使用(2)</title>
    <url>/2019/08/01/Spring-Reactor%E4%BD%BF%E7%94%A8-2/</url>
    <content><![CDATA[<p>封装通用的reactor事件处理，无需自己去写事件，只需关心业务逻辑</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>实例化Reactor Bean,这里采用内部 Bean 方式实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//src/.../reactor/config/ReactorConfig.java</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class ReactorConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    Environment env() &#123;</span><br><span class="line">        return new Environment();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Primary</span><br><span class="line">    Reactor pool(Environment env) &#123;</span><br><span class="line">        return Reactors.reactor()</span><br><span class="line">                    .env(env)</span><br><span class="line">                    .dispatcher(Environment.THREAD_POOL)</span><br><span class="line">                    .get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    Reactor loop(Environment env) &#123;</span><br><span class="line">        return Reactors.reactor()</span><br><span class="line">                    .env(env)</span><br><span class="line">                    .dispatcher(Environment.EVENT_LOOP)</span><br><span class="line">                    .get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>公共事件处理，即实现了InitializingBean初始化，也实现了业务逻辑的消费者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//src/.../reactor/BaseHandler.java</span><br><span class="line">public abstract class BaseHandler&lt;T&gt; implements InitializingBean, Consumer&lt;Event&lt;T&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 事件处理池(异步处理)</span><br><span class="line">     */</span><br><span class="line">    @Autowired</span><br><span class="line">    protected Reactor pool;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 事件处理队列(one by one)</span><br><span class="line">     */</span><br><span class="line">    @Autowired</span><br><span class="line">    @Qualifier(value = &quot;loop&quot;)</span><br><span class="line">    protected Reactor loop;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 选择器-获取class的小驼峰字符串$()组合</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    protected final Selector selector() &#123;</span><br><span class="line">        //reactor.on(********$(&quot;userHandler&quot;)*********, userHandler);</span><br><span class="line">        return $(this.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 键选择器-获取class的小驼峰字符串</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    protected final String selectorKey() &#123;</span><br><span class="line">        return this.getClass().getSimpleName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 事件的监听器，以便于接收发送的事件并处理。需要实现 Consumer&lt;Event&lt;T&gt;&gt; 接口，其中 T 是处理程序接收的数据类型</span><br><span class="line">     * 封装公共使用</span><br><span class="line">     * @param tEvent</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(Event&lt;T&gt; tEvent) &#123;</span><br><span class="line">        this.handler(tEvent.getData(), tEvent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 发送的事件绑定到指定的监听器</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">        this.register();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 封装公共发送事件方法</span><br><span class="line">     * @param o</span><br><span class="line">     */</span><br><span class="line">    public void notify(T o) &#123;</span><br><span class="line">        pool.notify(selectorKey(), Event.wrap(o));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final void notify(Event o) &#123;</span><br><span class="line">        pool.notify(selectorKey(), o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected abstract void handler(T o, Event&lt;T&gt; tEvent);</span><br><span class="line"></span><br><span class="line">    protected void register() throws Exception &#123;</span><br><span class="line">        pool.on(selector(), this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后续编写对应自己需要的异步操作，创建一个类继承BaseHandler传入dto泛型，实现handler就完成了，无需自己去编写绑定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//src/.../reactor/handler/Article.java</span><br><span class="line">@Slf4j</span><br><span class="line">@Component</span><br><span class="line">public class ArticleHandler extends BaseHandler&lt;ArticleDto&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    ArticleMapper articleMapper;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void handler(ArticleDto articleDto, Event&lt;ArticleDto&gt; articleDtoEvent) &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            ArticleDto article = articleMapper.getArticle(articleDto.getId());</span><br><span class="line">            log.info(&quot;in ArticleHandler: article=&#123;&#125;&quot;, article);</span><br><span class="line">        &#125; catch(Exception e) &#123;</span><br><span class="line">            log.error(String.valueOf(e));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 如果需要大量的异步操作，可以重载修改notify和register</span><br><span class="line">     */</span><br><span class="line">//    @Override</span><br><span class="line">//    public void notify(ArticleDto articleDto) &#123;</span><br><span class="line">//        loop.notify(selectorKey(), Event.wrap(articleDto));</span><br><span class="line">//    &#125;</span><br><span class="line">//</span><br><span class="line">//    @Override</span><br><span class="line">//    protected void register() throws Exception &#123;</span><br><span class="line">//        loop.on(selector(), this);</span><br><span class="line">//    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Skill</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Reactor</tag>
      </tags>
  </entry>
  <entry>
    <title>关于gRPC和golang实现微服务的记录(二)</title>
    <url>/2019/04/16/go-kit%E5%92%8CgRPC%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>go-kit和gRPC结合使用</p>
<hr>
<h3 id="什么是Go-Kit"><a href="#什么是Go-Kit" class="headerlink" title="什么是Go Kit"></a>什么是Go Kit</h3><blockquote>
<p>Go kit is a collection of Go (golang) packages (libraries) that help you build robust, reliable, maintainable microservices. It was originally conceived as a toolkit to help larger (so-called modern enterprise) organizations adopt Go as an implementation language. But it very quickly “grew downward”, and now serves smaller startups and organizations just as well. For more about the origins of Go kit, see Go kit: Go in the modern enterprise.</p>
</blockquote>
<p>Go Kit是使用golang编写的一个微服务工具包，帮助开发者能够快速展开微服务开发的工作</p>
<h4 id="Transports-传输层"><a href="#Transports-传输层" class="headerlink" title="Transports 传输层"></a>Transports 传输层</h4><p>Go Kit 可以自由的去选择使用HTTP或者gRPC作为传输方式，你也可以在一个项目中使用HTTP API和RPC服务</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用gRPC</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	. . .</span><br><span class="line"></span><br><span class="line">	gRPCtransport <span class="string">&quot;github.com/go-kit/kit/transport/grpc&quot;</span></span><br><span class="line"></span><br><span class="line">	. . .</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用HTTP</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	. . .</span><br><span class="line"></span><br><span class="line">	httptransport <span class="string">&quot;github.com/go-kit/kit/transport/http&quot;</span></span><br><span class="line"></span><br><span class="line">	. . .</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="Endpoints-端点层"><a href="#Endpoints-端点层" class="headerlink" title="Endpoints 端点层"></a>Endpoints 端点层</h4><p>类似MVC设计模式下的Controller中的Action Handler，如果你使用了两个传输方式，你也需要两个方法来请求同一个端点(endpoint)</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// endpoint</span></span><br><span class="line"><span class="comment">// RPC endpoint 服务请求响应适配器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeBookInfoEndpoint</span><span class="params">()</span></span> endpoint.Endpoint &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, request <span class="keyword">interface</span>&#123;&#125;)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">		req := request.(*pb.BookInfoRequest)</span><br><span class="line">		b := <span class="built_in">new</span>(pb.BookInfoResponse)</span><br><span class="line">		b.BookId = req.BookId</span><br><span class="line">		b.BookName = <span class="string">&quot;人人都是产品经理&quot;</span></span><br><span class="line">		<span class="keyword">return</span> b, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Services-服务层"><a href="#Services-服务层" class="headerlink" title="Services 服务层"></a>Services 服务层</h4><p>实现所有业务逻辑的地方，将多个端点沾合在一起，Go Kit中，服务通常被定义为interface接口，这些接口包含需要被实现的业务(业务逻辑应该不了解端点或特别是传输域概念：您的服务不应该知道有关HTTP头或gRPC错误代码的任何信息)</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 服务接口</span></span><br><span class="line"><span class="keyword">type</span> StringService <span class="keyword">interface</span> &#123;</span><br><span class="line">	Uppercase(<span class="type">string</span>) (<span class="type">string</span>, <span class="type">error</span>)</span><br><span class="line">	Count(<span class="type">string</span>) <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口实现</span></span><br><span class="line"><span class="keyword">type</span> stringService <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stringService)</span></span> Uppercase(s <span class="type">string</span>) (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> s == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, ErrEmpty</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> strings.ToUpper(s), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stringService)</span></span> Count(s <span class="type">string</span>) <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Middlewares-中间件"><a href="#Middlewares-中间件" class="headerlink" title="Middlewares 中间件"></a>Middlewares 中间件</h4><p>目前在学习中了解到了使用etcd作为注册中心，Go Kit提供的负载均衡，使用DelayingLimiter限流器。熔断机制和服务请求追踪还未去接触</p>
<h6 id="使用Etcd注册中心-amp-负载均衡-amp-限流器的使用"><a href="#使用Etcd注册中心-amp-负载均衡-amp-限流器的使用" class="headerlink" title="使用Etcd注册中心 &amp; 负载均衡 &amp; 限流器的使用"></a>使用Etcd注册中心 &amp; 负载均衡 &amp; 限流器的使用</h6><blockquote>
<p>关于etcd存储的文章学习：<a href="https://www.cnblogs.com/softidea/p/6517959.html">https://www.cnblogs.com/softidea/p/6517959.html</a></p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下载最近的etcd存储仓库：https://github.com/etcd-io/etcd/releases &amp; https://www.linuxidc.com/Linux/2015-02/112763.htm</span></span><br><span class="line"><span class="comment">// 设置为环境变量，使用 $ etcd，将它启起来，监听2379端口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	<span class="comment">// 服务实例地址</span></span><br><span class="line">	instanceAddr = <span class="string">&quot;127.0.0.1:50051&quot;</span></span><br><span class="line">	<span class="comment">// etcd服务地址</span></span><br><span class="line">	etcdAddr     = <span class="string">&quot;127.0.0.1:2379&quot;</span></span><br><span class="line">	<span class="comment">// 服务的信息目录</span></span><br><span class="line">	prefix       = <span class="string">&quot;/services/book/&quot;</span></span><br><span class="line">	<span class="comment">// 服务实例注册的路径</span></span><br><span class="line">	key          = prefix + instanceAddr</span><br><span class="line">	<span class="comment">// 服务实例注册的val</span></span><br><span class="line">	value        = instanceAddr</span><br><span class="line">	ctx          = context.Background()</span><br><span class="line">	<span class="comment">// 服务监听的端口</span></span><br><span class="line">	serviceAddr  = <span class="string">&quot;:50051&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// etcd的连接参数</span></span><br><span class="line">	options := etcdv3.ClientOptions&#123;</span><br><span class="line">		DialTimeout: time.Second * <span class="number">3</span>,</span><br><span class="line">		DialKeepAlive: time.Second * <span class="number">3</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 创建etcd连接</span></span><br><span class="line">	client, err := etcdv3.NewClient(ctx, []<span class="type">string</span>&#123;etcdAddr&#125;, options)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		grpclog.Fatalln(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建注册器</span></span><br><span class="line">	registrar := etcdv3.NewRegistrar(client, etcdv3.Service&#123;</span><br><span class="line">		Key: key,</span><br><span class="line">		Value: value,</span><br><span class="line">	&#125;, log.NewNopLogger())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注册器启动注册</span></span><br><span class="line">	registrar.Register()</span><br><span class="line"></span><br><span class="line">	server := <span class="built_in">new</span>(BookService)</span><br><span class="line"></span><br><span class="line">	bookListEndpoint := makeBookListEndpoint()</span><br><span class="line">	<span class="comment">// 创建限流器 1r/s</span></span><br><span class="line">	bookListLimiter := rate.NewLimiter(rate.Every(time.Second * <span class="number">1</span>), <span class="number">1</span>)</span><br><span class="line">	<span class="comment">// 通过DelayingLimiter中间件，在bookListEndpoint的外层再包裹一层限流的endpoint</span></span><br><span class="line">	bookListEndpoint = ratelimit.NewDelayingLimiter(bookListLimiter)(bookListEndpoint)</span><br><span class="line">	<span class="comment">// 创建handler</span></span><br><span class="line">	bookListHandler := gRPCtransport.NewServer(</span><br><span class="line">		bookListEndpoint,</span><br><span class="line">		decodeReq,</span><br><span class="line">		encodeRes,</span><br><span class="line">	)</span><br><span class="line">	<span class="comment">// go-kik 处理逻辑</span></span><br><span class="line">	server.bookListHandler = bookListHandler</span><br><span class="line"></span><br><span class="line">	bookInfoEndpoint := makeBookInfoEndpoint()</span><br><span class="line">	bookInfoLimiter := rate.NewLimiter(rate.Every(time.Second * <span class="number">1</span>), <span class="number">1</span>)</span><br><span class="line">	bookInfoEndpoint = ratelimit.NewDelayingLimiter(bookInfoLimiter)(bookInfoEndpoint)</span><br><span class="line">	bookInfoHandler := gRPCtransport.NewServer(</span><br><span class="line">		bookInfoEndpoint,</span><br><span class="line">		decodeReq,</span><br><span class="line">		encodeRes,</span><br><span class="line">	)</span><br><span class="line">	server.bookInfoHandler = bookInfoHandler</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动gRPC服务</span></span><br><span class="line">	listen, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, serviceAddr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		grpclog.Fatalf(<span class="string">&quot;failed to listen: \n%v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	gRPCserver := grpc.NewServer(grpc.UnaryInterceptor(gRPCtransport.Interceptor))</span><br><span class="line">	pb.RegisterBookServiceServer(gRPCserver, server)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;Listen port on &quot;</span>, serviceAddr)</span><br><span class="line">	gRPCserver.Serve(listen)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试负载均衡，只需在新建个server_1.go文件，将服务端代码复制进去，修改监听端口(50052),客服端进行轮询</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/go-kit/kit/endpoint&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/go-kit/kit/log&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/go-kit/kit/sd&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/go-kit/kit/sd/etcdv3&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/go-kit/kit/sd/lb&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc/grpclog&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	pb <span class="string">&quot;microservice-demo/gRPC/book/proto&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	addr = <span class="string">&quot;127.0.0.1:50051&quot;</span></span><br><span class="line">	<span class="comment">// etcd服务地址 注册中心地址</span></span><br><span class="line">	etcdAddr = <span class="string">&quot;127.0.0.1:2379&quot;</span></span><br><span class="line">	<span class="comment">// 监听的服务前缀</span></span><br><span class="line">	prefix   = <span class="string">&quot;/services/book/&quot;</span></span><br><span class="line">	ctx      = context.Background()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	options := etcdv3.ClientOptions&#123;</span><br><span class="line">		DialTimeout: time.Second * <span class="number">3</span>,</span><br><span class="line">		DialKeepAlive: time.Second * <span class="number">3</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 连接注册中心</span></span><br><span class="line">	client, err := etcdv3.NewClient(ctx, []<span class="type">string</span>&#123;etcdAddr&#125;, options)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		grpclog.Fatalln(<span class="string">&quot;client error: &quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	logger := log.NewNopLogger()</span><br><span class="line">	<span class="comment">// 实例管理器</span></span><br><span class="line">	<span class="comment">// 监听etcd中prefix的目录变化更新缓存的实例数据</span></span><br><span class="line">	instancer, err := etcdv3.NewInstancer(client, prefix, logger)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		grpclog.Fatalln(<span class="string">&quot;instancer error: &quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// endpoint管理器</span></span><br><span class="line">	<span class="comment">// 根据Factory和监听得到实例创建endpoint并订阅实例管理器的变化动态更新Factory创建的endpoint</span></span><br><span class="line">	endpointer := sd.NewEndpointer(instancer, reqFactory, logger)</span><br><span class="line">	<span class="comment">// 负载均衡器</span></span><br><span class="line">	balancer := lb.NewRoundRobin(endpointer)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1.可以通过负载均衡器直接获取请求的endpoint，发起请求</span></span><br><span class="line">	<span class="comment">// 2.也可以通过retry定义尝试次数进行请求</span></span><br><span class="line">	reqEndpoint := lb.Retry(<span class="number">3</span>, time.Second * <span class="number">3</span>, balancer)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过endpoint发起请求</span></span><br><span class="line">	<span class="keyword">var</span> req <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 轮询</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">8</span>; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;请求服务: &quot;</span>, addr, <span class="string">&quot;当前时间: &quot;</span>, time.Now().Format(<span class="string">&quot;2006-01-02 15:04:05.99&quot;</span>))</span><br><span class="line">		<span class="keyword">if</span> _, err := reqEndpoint(ctx, req); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			grpclog.Errorln(<span class="string">&quot;reqEndpoint error: &quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据实例地址 创建对应请求的endpoint</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reqFactory</span><span class="params">(instanceAddr <span class="type">string</span>)</span></span> (endpoint.Endpoint, io.Closer, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, request <span class="keyword">interface</span>&#123;&#125;)</span></span> (response <span class="keyword">interface</span>&#123;&#125;, err <span class="type">error</span>) &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;请求服务：&quot;</span>, instanceAddr)</span><br><span class="line">		conn, err := grpc.Dial(instanceAddr, grpc.WithInsecure())</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			grpclog.Errorln(<span class="string">&quot;connect error: &quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">defer</span> conn.Close()</span><br><span class="line">		bookClient := pb.NewBookServiceClient(conn)</span><br><span class="line">		bookInfo, _ := bookClient.GetBookInfo(context.Background(), &amp;pb.BookInfoRequest&#123; BookId: <span class="number">1</span> &#125;)</span><br><span class="line">		fmt.Println(<span class="string">&quot;书籍详情&quot;</span>)</span><br><span class="line">		fmt.Println(<span class="string">&quot;bookId: 1&quot;</span>, <span class="string">&quot; =&gt; &quot;</span>, <span class="string">&quot;bookName: &quot;</span>, bookInfo.BookName)</span><br><span class="line"></span><br><span class="line">		bookList, _ := bookClient.GetBookList(context.Background(), &amp;pb.BookListRequest&#123; Page: <span class="number">1</span>, Limit: <span class="number">10</span> &#125;)</span><br><span class="line">		fmt.Println(<span class="string">&quot;书籍列表&quot;</span>)</span><br><span class="line">		<span class="keyword">for</span> _, item := <span class="keyword">range</span> bookList.BookList &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;bookId: &quot;</span>, item.BookId, <span class="string">&quot; =&gt; &quot;</span>, <span class="string">&quot;bookName: &quot;</span>, item.BookName)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Skill</category>
        <category>golang</category>
      </categories>
      <tags>
        <tag>gRPC</tag>
        <tag>golang</tag>
        <tag>微服务</tag>
        <tag>go-kit</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx扩展conf配置文件和https</title>
    <url>/2019/03/04/nginx%E6%89%A9%E5%B1%95conf%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%92%8Chttps/</url>
    <content><![CDATA[<p>记录自己服务器中配置nginx配置文件从其他的扩展配置，简化nginx.conf，按站点配置，更能直观修改和查看</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># nginx.conf</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">#pid        logs/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    # 此处include进vhost目录下的所有.conf文件</span><br><span class="line">    include       vhost/*.conf;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    #access_log  logs/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li><p>在nginx.conf同目录创建vhost目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># /usr/local/nginx/conf/</span><br><span class="line">mkdir vhost</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个toy.conf文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># /usr/local/nginx/conf/</span><br><span class="line">touch toy.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写站点配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># vhost/toy.conf</span><br><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name toy.reimu.ru;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">                root /home/frontend/marisa;</span><br><span class="line">                index index.html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location /api/v1/ &#123;</span><br><span class="line">                proxy_pass http://127.0.0.1:3000/;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>https(证书使用let’s encrypt免费证书)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># vhost/toy.conf</span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name toy.reimu.ru;</span><br><span class="line"></span><br><span class="line">    root /home/frontend/marisa;</span><br><span class="line">    index index.html;</span><br><span class="line"></span><br><span class="line">    ssl on;</span><br><span class="line">    ssl_certificate /etc/letsencrypt/live/toy.reimu.ru/fullchain.pem;</span><br><span class="line">    ssl_certificate_key /etc/letsencrypt/live/toy.reimu.ru/privkey.pem;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        try_files $uri $uri/ =404;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /api/v1/ &#123;</span><br><span class="line">        proxy_pass http://127.0.0.1:3000/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用certbot-auto续签let’s encrypt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装并给予可执行权限</span><br><span class="line">wget https://dl.eff.org/certbot-auto</span><br><span class="line">chmod a+x certbot-auto</span><br><span class="line"># 需要安装python依赖</span><br></pre></td></tr></table></figure>
<p>如果是第一次的话，需要输入你的邮箱和其他相关信息，我过去有签过let’s encrypt，在/etc/letsencrypt/目录下有存在ssl证书路径</p>
</li>
<li><p>检查和续签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 检查是否过期</span><br><span class="line">./certbot-auto certificates</span><br><span class="line">Saving debug log to /var/log/letsencrypt/letsencrypt.log</span><br><span class="line"></span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">Found the following certs:</span><br><span class="line">  Certificate Name: toy.reimu.ru</span><br><span class="line">    Domains: toy.reimu.ru</span><br><span class="line">    Expiry Date: 2019-03-19 12:02:01+00:00 (INVALID: EXPIRED)</span><br><span class="line">    Certificate Path: /etc/letsencrypt/live/toy.reimu.ru/fullchain.pem</span><br><span class="line">    Private Key Path: /etc/letsencrypt/live/toy.reimu.ru/privkey.pem</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line"></span><br><span class="line"># 续签</span><br><span class="line">./certbot-auto renew --cert-name toy.reimu.ru</span><br><span class="line"></span><br><span class="line">Saving debug log to /var/log/letsencrypt/letsencrypt.log</span><br><span class="line"></span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">Processing /etc/letsencrypt/renewal/toy.reimu.ru.conf</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">Cert is due for renewal, auto-renewing...</span><br><span class="line">Plugins selected: Authenticator webroot, Installer None</span><br><span class="line">Renewing an existing certificate</span><br><span class="line">Performing the following challenges:</span><br><span class="line">http-01 challenge for toy.reimu.ru</span><br><span class="line">Waiting for verification...</span><br><span class="line">Cleaning up challenges</span><br><span class="line"></span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">new certificate deployed without reload, fullchain is</span><br><span class="line">/etc/letsencrypt/live/toy.reimu.ru/fullchain.pem</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line"></span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line"></span><br><span class="line">Congratulations, all renewals succeeded. The following certs have been renewed:</span><br><span class="line">  /etc/letsencrypt/live/toy.reimu.ru/fullchain.pem (success)</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">root@vultr:/home/download# ./certbot-auto certificates</span><br><span class="line">Saving debug log to /var/log/letsencrypt/letsencrypt.log</span><br><span class="line"></span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">Found the following certs:</span><br><span class="line">  Certificate Name: toy.reimu.ru</span><br><span class="line">    Domains: toy.reimu.ru</span><br><span class="line">    Expiry Date: 2019-06-23 02:24:26+00:00 (VALID: 89 days)</span><br><span class="line">    Certificate Path: /etc/letsencrypt/live/toy.reimu.ru/fullchain.pem</span><br><span class="line">    Private Key Path: /etc/letsencrypt/live/toy.reimu.ru/privkey.pem</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Skill</category>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>redis缓存数据库安装与golang中使用</title>
    <url>/2019/02/22/redis%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E8%A3%85%E4%B8%8Egolang%E4%B8%AD%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>最近公司在写数据可视化平台的一个项目，提供给公司运营内部使用。关于运营用户这方面，打算直接使用对应app的运营管理平台（另外一个使用java服务端）调用登陆接口，java服务端已经编写好接口，这边golang直接调用他们那的接口，这边处理存储请求获取到的用户信息和存储token的功能，就有了redis缓存相关的操作。在测试中，本来是用的运营管理平台的redis缓存服务器，不过我打算在我自己的服务器，直接搭建个redis缓存数据库。仅记此文章，作为查询和学习的记录。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul>
<li>在redis官网中下载tar.gz压缩包，保证最新版，在你当前的目录下(我的是在/home/download/中)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 解压缩</span><br><span class="line">tar xzf redis-x.x.xx.tar.gz</span><br><span class="line"># cd进去进行编译</span><br><span class="line">cd redis-x.x.xx.tar.gz</span><br><span class="line">make</span><br></pre></td></tr></table></figure></li>
<li>编译完，在当前目录下会生成src的目录，编译完成的所有项都在这里面(redis-server、redis-cli)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 当前目录：/home/download/redis-x.x.xx</span><br><span class="line"># 将redis文件移动到/usr/local/目录下，不移动也可以，我不打算做环境变量，保证我每次都能记得文件包在哪</span><br><span class="line"># 请务必记得也移动redis.conf配置文件</span><br><span class="line">cp -r ./src /usr/local/redis</span><br><span class="line">cp ./redis.conf /usr/local/redis/config/</span><br></pre></td></tr></table></figure>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3></li>
<li>修改redis.conf配置文件<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># /usr/local/redis/config/redis.conf</span><br><span class="line">vi redis.conf</span><br><span class="line"></span><br><span class="line"># 关于redis.conf中的项，可以去查询文档，这边修改这些项</span><br><span class="line">requirepass xxxxxxxx # 开启auth密码验证(如果在服务端中设置了密码登陆，这边不设置的话，会出现“ERR Client sent AUTH, but no password is set”)</span><br><span class="line">bind 0.0.0.0 # 如果在服务器厂商那开放了6379端口，任然不能从本地连接服务器redis的话，可以进行设置</span><br><span class="line">daemon yes # 设置为守护进程，这个不多说</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li>开启持久化和配置文件启动<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># /usr/local/redis</span><br><span class="line">./redis-server ./config/redis.conf --appendonly yes</span><br></pre></td></tr></table></figure></li>
<li>关于redis持久化的文章：<a href="https://blog.csdn.net/weixin_39040059/article/details/79120444">谈谈Redis持久化（下）——AOF（Append Only File）</a><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 接上</span><br><span class="line"># 使用redis终端进行测试</span><br><span class="line">./redis-cli</span><br></pre></td></tr></table></figure></li>
<li>在本地中的使用，本地使用的是windwos端的RedisDesktopManager</li>
</ul>
<h3 id="Golang代码编写"><a href="#Golang代码编写" class="headerlink" title="Golang代码编写"></a>Golang代码编写</h3><p>直接上代码吧</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Config/config.ini</span><br><span class="line">[redis]</span><br><span class="line">ADDR = your server address:6379</span><br><span class="line">PASSWORD = 123456</span><br><span class="line">DB = 0</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Middlewares/Cache/redis.go</span></span><br><span class="line"><span class="keyword">package</span> Cache</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/go-redis/redis&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">	<span class="string">&quot;virtual-data/Middlewares/setting&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RedisStorage <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	instance *RedisStorage</span><br><span class="line">	once sync.Once</span><br><span class="line">	client *redis.Client</span><br><span class="line">	err <span class="type">error</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Instance</span><span class="params">()</span></span> *RedisStorage &#123;</span><br><span class="line">	once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		instance = &amp;RedisStorage&#123;&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RedisStorage)</span></span> Init() (issue <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		addr, password <span class="type">string</span></span><br><span class="line">		db <span class="type">int</span></span><br><span class="line">	)</span><br><span class="line">	sec, err := setting.Cfg.GetSection(<span class="string">&quot;redis&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Errorf(<span class="string">&quot;Fial to get config section &#x27;redis&#x27;: %s\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	addr = sec.Key(<span class="string">&quot;ADDR&quot;</span>).String()</span><br><span class="line">	password = sec.Key(<span class="string">&quot;PASSWORD&quot;</span>).String()</span><br><span class="line">	db, _ = sec.Key(<span class="string">&quot;DB&quot;</span>).Int()</span><br><span class="line"></span><br><span class="line">	client = redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">		Addr: addr,</span><br><span class="line">		Password: password,</span><br><span class="line">		DB: db,</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	_, err = client.Ping().Result()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RedisStorage)</span></span> Set(key, value <span class="type">string</span>, expiration time.Duration) <span class="type">error</span> &#123;</span><br><span class="line">	err := client.Set(key, value, expiration).Err()</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RedisStorage)</span></span> Get(key <span class="type">string</span>) (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	result, err := client.Get(key).Result()</span><br><span class="line">	<span class="keyword">return</span> result, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RedisStorage)</span></span> Del(key <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">	err := client.Del(key).Err()</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在登陆控制器中使用"><a href="#在登陆控制器中使用" class="headerlink" title="在登陆控制器中使用"></a>在登陆控制器中使用</h4><ul>
<li>ViewModel 返回数据格式声明<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ViewModel/Login/v_login.go</span></span><br><span class="line"><span class="keyword">package</span> Login</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ResultData <span class="keyword">struct</span> &#123;</span><br><span class="line">	CreateTime <span class="type">int64</span> <span class="string">`json:&quot;createTime&quot;`</span></span><br><span class="line">	UserId <span class="type">int</span> <span class="string">`json:&quot;userId&quot;`</span></span><br><span class="line">	Token <span class="type">string</span> <span class="string">`json:&quot;token&quot;`</span></span><br><span class="line">	RealName <span class="type">string</span> <span class="string">`json:realName`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vresult <span class="keyword">struct</span> &#123;</span><br><span class="line">	Code <span class="type">int</span> <span class="string">`json:&quot;code&quot;`</span></span><br><span class="line">	Data ResultData <span class="string">`json:&quot;data&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Verror <span class="keyword">struct</span> &#123;</span><br><span class="line">	Code <span class="type">int</span> <span class="string">`json:&quot;code&quot;`</span></span><br><span class="line">	ThrowType <span class="type">string</span> <span class="string">`json:&quot;throwType&quot;`</span></span><br><span class="line">	Message <span class="type">string</span> <span class="string">`json:&quot;message&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>LoginController 登陆接口方法编写<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Controllers/LoginController.go</span></span><br><span class="line"><span class="keyword">package</span> Controllers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/astaxie/beego/validation&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/kataras/iris&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;net/url&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">	<span class="string">&quot;virtual-data/Middlewares/Cache&quot;</span></span><br><span class="line">	<span class="string">&quot;virtual-data/Middlewares/setting&quot;</span></span><br><span class="line">	VMlogin <span class="string">&quot;virtual-data/ViewModel/Login&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Login</span><span class="params">(ctx iris.Context)</span></span> &#123;</span><br><span class="line">	userName := ctx.Request().FormValue(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">	passWord := ctx.Request().FormValue(<span class="string">&quot;password&quot;</span>)</span><br><span class="line"></span><br><span class="line">	valid := validation.Validation&#123;&#125;</span><br><span class="line">	valid.Required(userName, <span class="string">&quot;username&quot;</span>).Message(<span class="string">&quot;账号不能为空&quot;</span>)</span><br><span class="line">	valid.Required(passWord, <span class="string">&quot;password&quot;</span>).Message(<span class="string">&quot;密码不能为空&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !valid.HasErrors() &#123;</span><br><span class="line">		result, err := requestJavaServerService(userName, passWord)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			ctx.JSON(Result(http.StatusBadGateway, err))</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			ctx.JSON(result)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ctx.JSON(Result(http.StatusBadRequest, valid.Errors[<span class="number">0</span>].Message))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请求java服务端接口，返回请求成功或错误的值</span></span><br><span class="line"><span class="comment"> * @method requestJavaServerService</span></span><br><span class="line"><span class="comment"> * @param username string</span></span><br><span class="line"><span class="comment"> * @param password string</span></span><br><span class="line"><span class="comment"> * @return interface&#123;&#125;</span></span><br><span class="line"><span class="comment"> * @return error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">requestJavaServerService</span><span class="params">(username, password <span class="type">string</span>)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">	client := &amp;http.Client&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">	<span class="keyword">var</span> urlAddr <span class="type">string</span></span><br><span class="line">	userInfo := url.Values&#123;&#125;</span><br><span class="line">	userInfo.Add(<span class="string">&quot;userName&quot;</span>, username)</span><br><span class="line">	userInfo.Add(<span class="string">&quot;password&quot;</span>, password)</span><br><span class="line"></span><br><span class="line">	sec, err := setting.Cfg.GetSection(<span class="string">&quot;request&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Errorf(<span class="string">&quot;Fial to get config section &#x27;request&#x27;: %s\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 在配置文件中配置好的请求地址</span></span><br><span class="line">	urlAddr = sec.Key(<span class="string">&quot;url&quot;</span>).String()</span><br><span class="line"></span><br><span class="line">	request, err := http.NewRequest(</span><br><span class="line">		<span class="string">&quot;POST&quot;</span>,</span><br><span class="line">		urlAddr,</span><br><span class="line">		strings.NewReader(userInfo.Encode()),</span><br><span class="line">	)</span><br><span class="line">	request.Header.Set(<span class="string">&quot;Content-type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>)</span><br><span class="line">	request.Header.Set(<span class="string">&quot;cms-token&quot;</span>, <span class="string">&quot;null&quot;</span>)</span><br><span class="line">	request.Header.Set(<span class="string">&quot;cms-channel&quot;</span>, <span class="string">&quot;0&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	parseObj, err := parseResponseBody(client, request)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> parseObj, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> tempBody <span class="keyword">struct</span> &#123;</span><br><span class="line">	Code <span class="type">int</span> <span class="string">`json:&quot;code&quot;`</span></span><br><span class="line">	Data <span class="keyword">interface</span>&#123;&#125; <span class="string">`json:&quot;data&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理请求成功的body</span></span><br><span class="line"><span class="comment"> * @method parseResponseBody</span></span><br><span class="line"><span class="comment"> * @param client *http.Client</span></span><br><span class="line"><span class="comment"> * @param request *http.Request</span></span><br><span class="line"><span class="comment"> * @return obj interface&#123;&#125;</span></span><br><span class="line"><span class="comment"> * @return err error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseResponseBody</span><span class="params">(client *http.Client, request *http.Request)</span></span> (obj <span class="keyword">interface</span>&#123;&#125;, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> resultObj VMlogin.Vresult</span><br><span class="line">	<span class="keyword">var</span> errorObj VMlogin.Verror</span><br><span class="line">	<span class="keyword">var</span> tempObj tempBody</span><br><span class="line">	resp, err := client.Do(request)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"></span><br><span class="line">	body, _ := ioutil.ReadAll(resp.Body)</span><br><span class="line">	err = json.Unmarshal(body, &amp;tempObj)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> tempObj.Code == <span class="number">200</span> &#123;</span><br><span class="line">		_ = json.Unmarshal(body, &amp;resultObj)</span><br><span class="line">		obj = resultObj</span><br><span class="line">		<span class="keyword">if</span> err = cacheManagerService(resultObj); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		_ = json.Unmarshal(body, &amp;errorObj)</span><br><span class="line">		obj = errorObj</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> obj, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置处理缓存的工厂</span></span><br><span class="line"><span class="comment"> * @method cacheManagerService</span></span><br><span class="line"><span class="comment"> * @param resultObj VMlogin.Vresult</span></span><br><span class="line"><span class="comment"> * @return error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cacheManagerService</span><span class="params">(resultObj VMlogin.Vresult)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> oldResultObj VMlogin.Vresult</span><br><span class="line">	<span class="keyword">var</span> redisKey <span class="type">string</span></span><br><span class="line">	<span class="keyword">var</span> redisValue <span class="type">string</span></span><br><span class="line">	<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 组合查询用户信息的声明和赋值</span></span><br><span class="line">	redisKey = FormatRedisString(REDIS_KEY_USER, resultObj.Data.UserId)</span><br><span class="line">	redisJsonValue, _ := json.Marshal(resultObj.Data)</span><br><span class="line">	redisValue = <span class="type">string</span>(redisJsonValue)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 查询是否存在此用户</span></span><br><span class="line">	infoVal, _ := Cache.Instance().Get(redisKey)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// json反序列化查询到的json字符串，将存储在缓存中的值赋值到一个变量上</span></span><br><span class="line">	_ = json.Unmarshal([]<span class="type">byte</span>(infoVal), &amp;oldResultObj.Data)</span><br><span class="line">	<span class="comment">// 如果返回空字符串，则是新用户，创建新的缓存</span></span><br><span class="line">	<span class="comment">// 否则根据缓存的token组合去将旧的缓存删除，覆盖新的用户信息和创建新的token</span></span><br><span class="line">	<span class="keyword">if</span> infoVal == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="comment">// 设置新的用户信息缓存</span></span><br><span class="line">		err = Cache.Instance().Set(redisKey, redisValue, <span class="number">744</span> * time.Hour)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 设置新的token信息缓存</span></span><br><span class="line">		redisKey = FormatRedisString(REDIS_KEY_TOKEN, resultObj.Data.Token)</span><br><span class="line">		redisValue = strconv.Itoa(resultObj.Data.UserId)</span><br><span class="line">		err = Cache.Instance().Set(redisKey, redisValue, <span class="number">744</span> * time.Hour)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 声明并赋值旧的token信息</span></span><br><span class="line">		oldToken := oldResultObj.Data.Token</span><br><span class="line">		<span class="comment">// 删除旧的token</span></span><br><span class="line">		err = Cache.Instance().Del(FormatRedisString(REDIS_KEY_TOKEN, oldToken))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 设置覆盖新的用户信息</span></span><br><span class="line">		err = Cache.Instance().Set(redisKey, redisValue, <span class="number">744</span> * time.Hour)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 设置新的token</span></span><br><span class="line">		redisKey = FormatRedisString(REDIS_KEY_TOKEN, resultObj.Data.Token)</span><br><span class="line">		redisValue = strconv.Itoa(resultObj.Data.UserId)</span><br><span class="line">		err = Cache.Instance().Set(redisKey, redisValue, <span class="number">744</span> * time.Hour)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Skill</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>security oauth2 password登陆认证相关(1) - 关于grant type</title>
    <url>/2020/03/13/security-oauth2-grant-type-password%E7%99%BB%E9%99%86%E8%AE%A4%E8%AF%81%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>请求OAuth微服务服务器接口**<em>oauth/login**</em>验证信息返回token，并将token进行缓存持久化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AkariServer-oauth: package org.springframework.security.oauth2.provider.endpoint;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Principal: 用户安全标识，实现此接口(Principal)的类</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> principal</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> parameters</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> HttpRequestMethodNotSupportedException</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/oauth/login&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">postLogin</span><span class="params">(Principal principal, <span class="meta">@RequestParam</span> Map&lt;String, String&gt; parameters)</span> <span class="keyword">throws</span> HttpRequestMethodNotSupportedException &#123;</span><br><span class="line">    <span class="comment">//验证信息返回token</span></span><br><span class="line">    <span class="keyword">return</span> MVF.filterData(handleAccessToken(principal, parameters));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> OAuth2AccessToken <span class="title function_">handleAccessToken</span><span class="params">(Principal principal, Map&lt;String, String&gt; parameters)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(principal <span class="keyword">instanceof</span> Authentication)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InsufficientAuthenticationException</span>(<span class="string">&quot;There is no client authentication. Try adding an appropriate authentication filter.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">clientId</span> <span class="operator">=</span> getClientId(principal);</span><br><span class="line">    <span class="comment">//获取客户端信息</span></span><br><span class="line">    <span class="type">ClientDetails</span> <span class="variable">authenticatedClient</span> <span class="operator">=</span> getClientDetailsService().loadClientByClientId(clientId);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * TokenRequest:</span></span><br><span class="line"><span class="comment">      * 表示在发出的OAuth2令牌请求TokenEndpoint。requestParameters映射应包含原始OAuth2请求中未经修改的原始参数。</span></span><br><span class="line"><span class="comment">      * 在隐式流中，AuthorizationEndpoint直接通过令牌请求令牌，在这种情况下 ，令牌AuthorizationRequest会转换为TokenRequest令牌，</span></span><br><span class="line"><span class="comment">      * 以通过令牌授权链进行处理。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="type">TokenRequest</span> <span class="variable">tokenRequest</span> <span class="operator">=</span> getDefaultOAuth2RequestFactory().createTokenRequest(parameters, authenticatedClient);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clientId != <span class="literal">null</span> &amp;&amp; !clientId.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">//Only validate the client details if a client authenticated during thi request.</span></span><br><span class="line">        <span class="keyword">if</span> (!clientId.equals(tokenRequest.getClientId())) &#123;</span><br><span class="line">            <span class="comment">//double check to make sure that the client ID in the token request is the same as that in the</span></span><br><span class="line">            <span class="comment">//authenticated client</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidClientException</span>(<span class="string">&quot;Given client ID does not match authenticated client&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (authenticatedClient != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//确保客户端已请求一组有效的作用域。</span></span><br><span class="line">        oAuth2RequestValidator.validateScope(tokenRequest, authenticatedClient);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * grant_type：表示使用的授权模式</span></span><br><span class="line"><span class="comment">      * 授权模式不能为空</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(tokenRequest.getGrantType())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidRequestException</span>(<span class="string">&quot;Missing grant type&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * implicit不能含有</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">if</span> (tokenRequest.getGrantType().equals(<span class="string">&quot;implicit&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidGrantException</span>(<span class="string">&quot;Implicit grant type not supported from token endpoint&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 清除tokenRequest的作用域</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">if</span> (isAuthCodeRequest(parameters)) &#123;</span><br><span class="line">        <span class="comment">//The scope was requested or determined during the authorization step</span></span><br><span class="line">        <span class="keyword">if</span> (!tokenRequest.getScope().isEmpty()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Clearing scope of incoming token request&quot;</span>);</span><br><span class="line">            tokenRequest.setScope(Collections.emptySet());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 判断是刷新token的请求的话设置令牌请求的作用域</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">if</span> (isRefreshTokenRequest(parameters)) &#123;</span><br><span class="line">        <span class="comment">//A refresh token has its own default scopes, so we should ignore any added by the factory here.</span></span><br><span class="line">        tokenRequest.setScope(OAuth2Utils.parseParameterList(parameters.get(OAuth2Utils.SCOPE)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 授权获取accessToken</span></span><br><span class="line"><span class="comment">      * grant type:</span></span><br><span class="line"><span class="comment">      * sms: 走到 SmsGranter 执行继承的 统一第三方认证抽象类（包括手机号码认证）access方法</span></span><br><span class="line"><span class="comment">      * &#123;<span class="doctag">@link</span> ru.reimu.akariserver.auth.granter.bean.AbstractThirdPartyGranter.access(ClientDetails client, TokenRequest tokenRequest)&#125;</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * password: 走到PasswordGranter 执行继承抽象授权者重载的getOAuth2Authentication方法 &#123;<span class="doctag">@link</span> ru.reimu.akariserver.auth.granter.bean.PasswordGranter&#125;</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="type">OAuth2AccessToken</span> <span class="variable">token</span> <span class="operator">=</span> getTokenGranter().grant(tokenRequest.getGrantType(), tokenRequest);</span><br><span class="line">    <span class="keyword">if</span> (token == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedGrantTypeException</span>(<span class="string">&quot;Unsupported grant type: &quot;</span> + tokenRequest.getGrantType());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> token;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>重点是这段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 授权获取accessToken</span></span><br><span class="line"><span class="comment">  * grant type:</span></span><br><span class="line"><span class="comment">  * sms: 走到 SmsGranter 执行继承的 统一第三方认证抽象类（包括手机号码认证）access方法</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@link</span> ru.reimu.akariserver.auth.granter.bean.AbstractThirdPartyGranter.access(ClientDetails client, TokenRequest tokenRequest)&#125;</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * password: 走到PasswordGranter 执行继承抽象授权者重载的getOAuth2Authentication方法 &#123;<span class="doctag">@link</span> ru.reimu.akariserver.auth.granter.bean.PasswordGranter&#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">OAuth2AccessToken</span> <span class="variable">token</span> <span class="operator">=</span> getTokenGranter().grant(tokenRequest.getGrantType(), tokenRequest);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行实现 <strong><em>继承AbstractEndpoint的getTokenGranter()方法实现的TokenGranter接口</em></strong> 的 <strong><em>grant</em></strong>方法，具体gettokenGranter方法可以自己查看源码，先来看看grant实现是在哪个位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Tomonori</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/11/27 16:16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Desc</span>: 自定义令牌配置</span></span><br><span class="line"><span class="comment"> *        认证服务器逻辑实现</span></span><br><span class="line"><span class="comment"> *        让认证服务器AuthorizationServerConfig继承AuthorizationServerConfigurerAdapter，</span></span><br><span class="line"><span class="comment"> *        并重写它的configure(ClientDetailsServiceConfigurer clients)方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAuthorizationServer</span></span><br><span class="line"><span class="comment">//开启自定义的@Granter注解</span></span><br><span class="line"><span class="meta">@EnableDefinitionGranter(&quot;ru.reimu.akariserver.auth.granter&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizationServerConfig</span> <span class="keyword">extends</span> <span class="title class_">AuthorizationServerConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;TokenGranter&gt; TokenGranters; <span class="comment">//授权者</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * endpoints配置是在 endpoint包下的EndpointsConfiguration类中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endpoints</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> &#123;</span><br><span class="line">        endpoints</span><br><span class="line">                .allowedTokenEndpointRequestMethods(HttpMethod.GET, HttpMethod.POST)</span><br><span class="line">                .tokenStore(redisTokenStore())</span><br><span class="line">                .tokenEnhancer(jwtAccessTokenConverter())</span><br><span class="line">                .authenticationManager(authenticationManager)</span><br><span class="line">                .reuseRefreshTokens(<span class="literal">false</span>)</span><br><span class="line">                .userDetailsService(userDetailsService)</span><br><span class="line">                .tokenServices(defaultTokenServices())</span><br><span class="line">                .exceptionTranslator(webResponseExceptionTranslator)</span><br><span class="line">                <span class="comment">/////////////////////////////////////////////////////////////</span></span><br><span class="line">                <span class="comment">//添加授权者</span></span><br><span class="line">                .tokenGranter(<span class="keyword">new</span> <span class="title class_">TokenGranter</span>() &#123;</span><br><span class="line">                    <span class="keyword">private</span> CompositeTokenGranter delegate;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> OAuth2AccessToken <span class="title function_">grant</span><span class="params">(String grantType, TokenRequest tokenRequest)</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">this</span>.delegate == <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="built_in">this</span>.delegate = <span class="keyword">new</span> <span class="title class_">CompositeTokenGranter</span>(TokenGranters);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> <span class="built_in">this</span>.delegate.grant(grantType, tokenRequest);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">/////////////////////////////////////////////////////////////</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以开到这里我们装配了一个TokenGranter的List的Beans，但是这些TokenGranter又是从哪里注入的呢？</p>
<h3 id="自定义-Granter-注解"><a href="#自定义-Granter-注解" class="headerlink" title="自定义 @Granter 注解"></a>自定义 @Granter 注解</h3><p>我们将借助ImportBeanDefinitionRegistrar接口实现granter bean的动态注入，即使用@Granter注解的类将在运行时时注入到容器，则上面授权服务器则能自动装配到实现TokenGranter的所有实现类了。</p>
<h4 id="Granter"><a href="#Granter" class="headerlink" title="@Granter"></a>@Granter</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Tomonori</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/12/2 14:33</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Desc</span>: 标记granter的注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Granter &#123;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">granterType</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="EnableDefinitionGranter"><a href="#EnableDefinitionGranter" class="headerlink" title="@EnableDefinitionGranter"></a>@EnableDefinitionGranter</h4><p>value值即上面授权服务器的自定义granter包<br>@EnableDefinitionGranter(“ru.reimu.akariserver.auth.granter”)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Tomonori</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/12/2 12:32</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Desc</span>: 开启自定义的<span class="doctag">@Granter</span>注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="comment">//@Import 把用到的资源注册到Bean</span></span><br><span class="line"><span class="meta">@Import(&#123;GranterDefinitionBeanRegister.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableDefinitionGranter &#123;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="动态注入代码实现"><a href="#动态注入代码实现" class="headerlink" title="动态注入代码实现"></a>动态注入代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Tomonori</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/12/2 14:21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Desc</span>: 授权者注册机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GranterDefinitionBeanRegister</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span>, BeanFactoryAware &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="built_in">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="built_in">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry beanDefinitionRegistry)</span> &#123;</span><br><span class="line">        <span class="comment">//获取注解的属性</span></span><br><span class="line">        <span class="type">AnnotationAttributes</span> <span class="variable">annoAttrs</span> <span class="operator">=</span> AnnotationAttributes.fromMap(annotationMetadata.getAnnotationAttributes(EnableDefinitionGranter.class.getName()));</span><br><span class="line">        <span class="type">String</span> <span class="variable">scanPackage</span> <span class="operator">=</span> annoAttrs.getString(<span class="string">&quot;value&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * loadClassesByAnnotationClass: 传入一个注解类型类，获取使用这个注解的所有的类型类</span></span><br><span class="line"><span class="comment">             * Metadata 元数据相关doc: https://www.jianshu.com/p/83725adc2d45</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Set&lt;Class&lt;?&gt;&gt; granterSet = ReflectionUtility.loadClassesByAnnotationClass(Granter.class, scanPackage.split(<span class="string">&quot;,&quot;</span>));</span><br><span class="line"></span><br><span class="line">            granterSet.forEach(granter -&gt; &#123;</span><br><span class="line">                <span class="type">Granter</span> <span class="variable">annotation</span> <span class="operator">=</span> granter.getAnnotation(Granter.class);</span><br><span class="line">                <span class="type">String</span> <span class="variable">granterType</span> <span class="operator">=</span> annotation.granterType();</span><br><span class="line">                <span class="comment">//创建bean</span></span><br><span class="line">                <span class="type">BeanDefinitionBuilder</span> <span class="variable">beanDefinitionBuilder</span> <span class="operator">=</span> BeanDefinitionBuilder.genericBeanDefinition(granter);</span><br><span class="line"></span><br><span class="line">                beanDefinitionBuilder.addConstructorArgValue(granterType);</span><br><span class="line">                <span class="comment">//注册bean</span></span><br><span class="line">                beanDefinitionRegistry.registerBeanDefinition(granter.getSimpleName(), beanDefinitionBuilder.getBeanDefinition());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Granter register error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Granter register error&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="选择对应的grant-type的tokenGranter"><a href="#选择对应的grant-type的tokenGranter" class="headerlink" title="选择对应的grant type的tokenGranter"></a>选择对应的grant type的tokenGranter</h3><p>接上面授权服务器，这里实例化了一个CompositeTokenGranter类，我们将执行这个grant方法。下面是代码实现，具体看注释。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> OAuth2AccessToken <span class="title function_">grant</span><span class="params">(String grantType, TokenRequest tokenRequest)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.delegate == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.delegate = <span class="keyword">new</span> <span class="title class_">CompositeTokenGranter</span>(TokenGranters);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.delegate.grant(grantType, tokenRequest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *package org.springframework.security.oauth2.provider.CompositeTokenGranter</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> OAuth2AccessToken <span class="title function_">grant</span><span class="params">(String grantType, TokenRequest tokenRequest)</span> &#123;</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">var3</span> <span class="operator">=</span> <span class="built_in">this</span>.tokenGranters.iterator();</span><br><span class="line"></span><br><span class="line">    OAuth2AccessToken grant;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!var3.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">TokenGranter</span> <span class="variable">granter</span> <span class="operator">=</span> (TokenGranter)var3.next();</span><br><span class="line">        <span class="comment">//注意这里的grant方法将会走实现TokenGranter的一个抽象类下的grant方法</span></span><br><span class="line">        <span class="comment">//即AbstractTokenGranter，package org.springframework.security.oauth2.provider.token;</span></span><br><span class="line">        grant = granter.grant(grantType, tokenRequest);</span><br><span class="line">    &#125; <span class="keyword">while</span>(grant == <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> grant;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//package org.springframework.security.oauth2.provider.token.AbstractTokenGranter</span></span><br><span class="line"><span class="keyword">public</span> OAuth2AccessToken <span class="title function_">grant</span><span class="params">(String grantType, TokenRequest tokenRequest)</span> &#123;</span><br><span class="line">    <span class="comment">//上面的grant方法中迭代这里判断返回对应的granter实现</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.grantType.equals(grantType)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">clientId</span> <span class="operator">=</span> tokenRequest.getClientId();</span><br><span class="line">        <span class="type">ClientDetails</span> <span class="variable">client</span> <span class="operator">=</span> <span class="built_in">this</span>.clientDetailsService.loadClientByClientId(clientId);</span><br><span class="line">        <span class="built_in">this</span>.validateGrantType(grantType, client);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.logger.debug(<span class="string">&quot;Getting access token for: &quot;</span> + clientId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getAccessToken(client, tokenRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后调用同包下的this.getAccessToken(ClientDetails client, TokenRequest tokenRequest)方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> OAuth2AccessToken <span class="title function_">getAccessToken</span><span class="params">(ClientDetails client, TokenRequest tokenRequest)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.tokenServices.createAccessToken(<span class="built_in">this</span>.getOAuth2Authentication(client, tokenRequest));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>this.getOAuth2Authentication(ClientDetails client, TokenRequest tokenRequest)就将执行我们选择的自定义授权者重载的代码</p>
<h4 id="自定的授权者PasswordGranter类"><a href="#自定的授权者PasswordGranter类" class="headerlink" title="自定的授权者PasswordGranter类"></a>自定的授权者PasswordGranter类</h4><p>先来看看里面的代码，到这里先不记录后续</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Tomonori</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/3/11 15:44</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Desc</span>: ↓ ↓ ↓ ↓ ↓</span></span><br><span class="line"><span class="comment"> * -----</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Granter(granterType = &quot;password&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PasswordGranter</span> <span class="keyword">extends</span> <span class="title class_">AbstractGranter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">PasswordGranter</span><span class="params">(String grantType, AuthorizationServerTokenServices tokenServices, ClientDetailsService clientDetailsService, OAuth2RequestFactory requestFactory, RabbitMQSender mqSender)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(grantType, tokenServices, clientDetailsService, requestFactory, mqSender);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> OAuth2Authentication <span class="title function_">getOAuth2Authentication</span><span class="params">(ClientDetails client, TokenRequest tokenRequest)</span> &#123;</span><br><span class="line">        Map&lt;String, String&gt; parameters = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(tokenRequest.getRequestParameters());</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> parameters.get(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> parameters.get(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        parameters.remove(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Authentication</span> <span class="variable">userAuth</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(username, password);</span><br><span class="line">        ((AbstractAuthenticationToken) userAuth).setDetails(parameters);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 走到AuthorizationServerConfig的configure(AuthorizationServerEndpointsConfigurer endpoints)方法</span></span><br><span class="line"><span class="comment">             * 下的grant(String grantType, TokenRequest tokenRequest) 方法</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 然后是 org.springframework.security.authentication.dao.AbstractUserDetailsAuthenticationProvider.authenticate(Authentication authentication)</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            userAuth = <span class="built_in">this</span>.authenticationManager.authenticate(userAuth);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AccountStatusException var8) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidGrantException</span>(var8.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BadCredentialsException var9) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidGrantException</span>(var9.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (userAuth != <span class="literal">null</span> &amp;&amp; userAuth.isAuthenticated()) &#123;</span><br><span class="line">            <span class="type">OAuth2Request</span> <span class="variable">storedOAuth2Request</span> <span class="operator">=</span> <span class="built_in">this</span>.getRequestFactory().createOAuth2Request(client, tokenRequest);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * return后将会去 &#123;<span class="doctag">@link</span> org.springframework.security.oauth2.provider.token.AbstractTokenGranter&#125;</span></span><br><span class="line"><span class="comment">             * getAccessToken(ClientDetails client, TokenRequest tokenRequest) 重载 &#123;<span class="doctag">@link</span> ru.reimu.akariserver.auth.config.MyTokenServices&#125;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OAuth2Authentication</span>(storedOAuth2Request, userAuth);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidGrantException</span>(<span class="string">&quot;Could not authenticate user: &quot;</span> + username);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> UserDetails <span class="title function_">access</span><span class="params">(ClientDetails client, TokenRequest tokenRequest)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>未完待续</p>
]]></content>
      <categories>
        <category>Skill</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
        <tag>Spring Security</tag>
        <tag>OAuth2</tag>
      </tags>
  </entry>
  <entry>
    <title>关于gRPC和golang实现微服务的记录(一)</title>
    <url>/2019/04/10/%E5%85%B3%E4%BA%8EgRPC%E5%92%8Cgolang%E5%AE%9E%E7%8E%B0%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<blockquote>
<p>RPC(Remote Procedure Call)是远程过程调用，比如说现在有两台服务器A, B，一个在A服务器上的应用想要调用B服务器上的应用提供的某个，由于不在两个方法不在一个内存空间，不能直接调用，需要通过网络表达调用的语义和传达调用的数据。常存在于分布式系统中。</p>
</blockquote>
<hr>
<blockquote>
<p>探讨tcp/http和RPC的区别的话，这里就不重复探讨了，戳：<a href="https://www.jianshu.com/p/959030de7f1c">https://www.jianshu.com/p/959030de7f1c</a></p>
</blockquote>
<h2 id="gRPC是什么"><a href="#gRPC是什么" class="headerlink" title="gRPC是什么"></a>gRPC是什么</h2><p>gRPC是谷歌开源的一个 RPC 框架，面向移动和 HTTP/2 设计。</p>
<p>服务端负责实现定义好的接口并处理客户端的请求，客户端根据接口描述直接调用需要的服务。客户端和服务端可以分别使用gPRC支持的不同语言实现。</p>
<p>ProtoBuf 具有强大的IDL（interface description language，接口描述语言）和相关工具集（主要是protoc）。用户写好.proto描述文件后，protoc可以将其编译成众多语言的接口代码。</p>
<blockquote>
<p>有了 gRPC， 我们可以一次性的在一个 .proto 文件中定义服务并使用任何支持它的语言去实现客户端和服务器，反过来，它们可以在各种环境中，从Google的服务器到你自己的平板电脑—— gRPC 帮你解决了不同语言及环境间通信的复杂性.使用 protocol buffers 还能获得其他好处，包括高效的序列号，简单的 IDL 以及容易进行接口更新。</p>
</blockquote>
<h2 id="Protobuf是什么"><a href="#Protobuf是什么" class="headerlink" title="Protobuf是什么"></a>Protobuf是什么</h2><p>Protobuf是一种平台无关、语言无关、可扩展且轻便高效的序列化数据结构的协议，可以用于网络通信和数据存储。</p>
<h3 id="使用和使用前"><a href="#使用和使用前" class="headerlink" title="使用和使用前"></a>使用和使用前</h3><p><a href="https://github.com/protocolbuffers/protobuf/releases">https://github.com/protocolbuffers/protobuf/releases</a></p>
<p>将protoc下载下来，设置环境变量，后面将只会展示编译生成的golang代码，protobuf支持其他多种语言</p>
<h2 id="golang-工具"><a href="#golang-工具" class="headerlink" title="golang 工具"></a>golang 工具</h2><p>拉取 golang的 grpc包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">在大陆的话，可以从https://github.com/grpc/grpc-go，将代码克隆下来放到你的gopath目录下src创建对应的文件夹存入</span></span><br><span class="line">go get google.golang.org/grpc</span><br></pre></td></tr></table></figure>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><blockquote>
<p>学习推荐： <a href="https://blog.csdn.net/lihao19910921/article/details/80166399">https://blog.csdn.net/lihao19910921/article/details/80166399</a></p>
</blockquote>
<p>初始代码结构</p>
<ul>
<li>demo<ul>
<li>hello<ul>
<li>client<ul>
<li>main.go</li>
</ul>
</li>
<li>server<ul>
<li>main.go</li>
</ul>
</li>
</ul>
</li>
<li>proto<ul>
<li>hello.proto</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>编写proto协议文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// demo/proto/hello.proto</span><br><span class="line">// 指定protobuf的版本</span><br><span class="line">syntax = &quot;proto3&quot;</span><br><span class="line"></span><br><span class="line">// 指定包名</span><br><span class="line">package hello;</span><br><span class="line"></span><br><span class="line">// 定义服务</span><br><span class="line">service HelloService &#123;</span><br><span class="line">  // 定义rpc方法 request response</span><br><span class="line">  rpc SayHello(HelloRequest) returns (HelloResponse) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 请求结构</span><br><span class="line">message HelloRequest &#123;</span><br><span class="line">  string name = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 响应结构</span><br><span class="line">message HelloResponse &#123;</span><br><span class="line">  string message = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用protoc将.proto文件编译成golang代码，包含服务端接口HelloServer描述，客户端接口及实现HelloClient，及HelloRequest、HelloResponse结构体</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">demo/proto/hello.proto</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">使用grpc框架</span></span><br><span class="line">protoc -I . --go_out=plugins=grpc:. ./hello.proto</span><br></pre></td></tr></table></figure>

<p>新的目录结构如下：</p>
<ul>
<li>demo<ul>
<li>hello<ul>
<li>client<ul>
<li>main.go</li>
</ul>
</li>
<li>server<ul>
<li>main.go</li>
</ul>
</li>
</ul>
</li>
<li>proto<ul>
<li>hello.proto</li>
<li>hello.pb.go</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="服务端和客户端实现"><a href="#服务端和客户端实现" class="headerlink" title="服务端和客户端实现"></a>服务端和客户端实现</h4><p>服务端</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// demo/hello/server/main.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc/grpclog&quot;</span></span><br><span class="line">	pb <span class="string">&quot;microservice-demo/gRPC/demo/proto&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// gRPC服务地址</span></span><br><span class="line">	addr = <span class="string">&quot;127.0.0.1:3000&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// helloService 实现约定的接口</span></span><br><span class="line"><span class="keyword">type</span> helloService <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> HelloService = helloService&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h helloService)</span></span> SayHello(_ context.Context, req *pb.HelloRequest) (*pb.HelloResponse, <span class="type">error</span>) &#123;</span><br><span class="line">	res := <span class="built_in">new</span>(pb.HelloResponse)</span><br><span class="line">	res.Message = <span class="string">&quot;Hello &quot;</span> + req.Name + <span class="string">&quot;.&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	listen, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, addr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		grpclog.Fatalf(<span class="string">&quot;failed to listen: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 实例化gRPC server</span></span><br><span class="line">	s := grpc.NewServer()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注册hello服务</span></span><br><span class="line">	pb.RegisterHelloServer(s, HelloService)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;Listen on &quot;</span> + addr)</span><br><span class="line"></span><br><span class="line">	s.Serve(listen)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc/grpclog&quot;</span></span><br><span class="line">	pb <span class="string">&quot;microservice-demo/gRPC/demo/proto&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// gRPC服务端服务地址</span></span><br><span class="line">	addr = <span class="string">&quot;127.0.0.1:3000&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 连接</span></span><br><span class="line">	conn, err := grpc.Dial(addr, grpc.WithInsecure())</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		grpclog.Fatalln(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化客服端</span></span><br><span class="line">	c := pb.NewHelloClient(conn)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用服务方法</span></span><br><span class="line">	reqBody := <span class="built_in">new</span>(pb.HelloRequest)</span><br><span class="line">	reqBody.Name = <span class="string">&quot;tomonori&quot;</span></span><br><span class="line">	<span class="comment">// 返回的是HelloResponse 响应结构体</span></span><br><span class="line">	r, err := c.SayHello(context.Background(), reqBody)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		grpclog.Fatalln(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 输出响应信息</span></span><br><span class="line">	fmt.Println(r.Message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终结果</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在服务端实现的接口方法</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h helloService)</span></span> SayHello(_ context.Context, req *pb.HelloRequest) (*pb.HelloResponse, <span class="type">error</span>) &#123;</span><br><span class="line">	res := <span class="built_in">new</span>(pb.HelloResponse)</span><br><span class="line">	res.Message = <span class="string">&quot;Hello &quot;</span> + req.Name + <span class="string">&quot;.&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">reqBody := <span class="built_in">new</span>(pb.HelloRequest)</span><br><span class="line">reqBody.Name = <span class="string">&quot;tomonori&quot;</span></span><br><span class="line"><span class="comment">// 返回的是HelloResponse 响应结构体</span></span><br><span class="line">r, err := c.SayHello(context.Background(), reqBody)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  grpclog.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出响应信息</span></span><br><span class="line">fmt.Println(r.Message)</span><br><span class="line"><span class="comment">// Hello tomonori</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="阅读资料"><a href="#阅读资料" class="headerlink" title="阅读资料"></a>阅读资料</h3><blockquote>
<p><a href="https://blog.csdn.net/lihao19910921/article/details/80166399">https://blog.csdn.net/lihao19910921/article/details/80166399</a><br><a href="http://doc.oschina.net/grpc?t=60133">http://doc.oschina.net/grpc?t=60133</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Skill</category>
        <category>golang</category>
      </categories>
      <tags>
        <tag>gRPC</tag>
        <tag>golang</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构(1) 单链表简单实现</title>
    <url>/2019/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1-%E5%8D%95%E9%93%BE%E8%A1%A8%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>单链表是一种链式存取的数据结构，用一组地址任意的存储单元存放线性表中的数据元素。链表中的数据是以结点来表示的，每个结点的构成：元素(数据元素的映象) + 指针(指示后继元素存储位置)，元素就是存储数据的存储单元，指针就是连接每个结点的地址数据</p>
<h3 id="简述意思"><a href="#简述意思" class="headerlink" title="简述意思"></a>简述意思</h3><p>链表是动态分配内存，时间复杂度O(1)。插入和删除速度快，内存利用率高，不会浪费内存(在需要空间的时候才会创建)，但是不能随机查找，只能遍历，且单链表只能根据一个指向下一个节点的指针往下遍历(next)。和数组对比，数组是静态分配内存，数组连续，可以根据下标进行定位(array[0])，可是数组的内存是连续的，比如在go里创建一个数组，需要给下标，且后续不可扩展(非slice切片)，数组可以随机查找，根据下标可以快速定位。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Object <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点 data值 next链节</span></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">    data Object</span><br><span class="line">    next *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表 size长度 head首个 tail尾部</span></span><br><span class="line"><span class="keyword">type</span> List <span class="keyword">struct</span> &#123;</span><br><span class="line">    size <span class="type">int</span></span><br><span class="line">    head *Node</span><br><span class="line">    tail *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *List)</span></span> Init() &#123;</span><br><span class="line">    list.size = <span class="number">0</span></span><br><span class="line">    list.head = <span class="literal">nil</span></span><br><span class="line">    list.tail = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素方法 添加到最后节点最里部</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *List)</span></span> Append(node *Node) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.next = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> list.size == <span class="number">0</span> &#123;</span><br><span class="line">        list.head = node</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        oldTail := list.tail</span><br><span class="line">        oldTail.next = node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    list.tail = node</span><br><span class="line">    list.size++</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入到链表中(插入到尾部的话可以直接用Append，故这里不做处理)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *List)</span></span> Insert(i <span class="type">int</span>, node *Node) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 空间点、超出索引大小和空链表无法插入</span></span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">nil</span> || i &gt; list.size || list.size == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">        node.next = list.head</span><br><span class="line">        list.head = node</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 上一个、前一个节点</span></span><br><span class="line">        prev := list.head</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; i; j++ &#123;</span><br><span class="line">            prev = prev.next</span><br><span class="line">        &#125;</span><br><span class="line">        node.next = prev.next</span><br><span class="line">        prev.next = node</span><br><span class="line">    &#125;</span><br><span class="line">    list.size++</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从链表中删除</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *List)</span></span> Delete(i <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i &gt; list.size || list.size == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">        list.head = list.head.next</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev := list.head</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; i; j++ &#123;</span><br><span class="line">            prev = prev.next</span><br><span class="line">        &#125;</span><br><span class="line">        next := prev.next.next</span><br><span class="line">        prev.next = next</span><br><span class="line">    &#125;</span><br><span class="line">    list.size--</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    list := &amp;List&#123;&#125;</span><br><span class="line">    list.Init()</span><br><span class="line">    node := &amp;Node&#123;</span><br><span class="line">        data: <span class="number">1</span>,</span><br><span class="line">        next: <span class="literal">nil</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    list.Append(node)</span><br><span class="line">    fmt.Println(list) <span class="comment">// &amp;&#123;1 0xc82000e0c0 0xc82000e0c0&#125;</span></span><br><span class="line">    node2 := &amp;Node&#123;</span><br><span class="line">        data: <span class="number">2</span>,</span><br><span class="line">        next: <span class="literal">nil</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    list.Append(node2)</span><br><span class="line">    fmt.Println(list) <span class="comment">// &amp;&#123;2 0xc82000e0c0 0xc82000e120&#125;</span></span><br><span class="line"></span><br><span class="line">    node3 := &amp;Node&#123;</span><br><span class="line">        data: <span class="number">3</span>,</span><br><span class="line">        next: <span class="literal">nil</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    list.Append(node3)</span><br><span class="line"></span><br><span class="line">    node4 := &amp;Node&#123;</span><br><span class="line">        data: <span class="number">4</span>,</span><br><span class="line">        next: <span class="literal">nil</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    list.Insert(<span class="number">1</span>, node4)</span><br><span class="line"></span><br><span class="line">    list.Delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Println(list.head.data) <span class="comment">// 1</span></span><br><span class="line">    fmt.Println(list.head.next.data) <span class="comment">// 2</span></span><br><span class="line">    fmt.Println(list.head.next.next.data) <span class="comment">// 3</span></span><br><span class="line">    <span class="comment">// fmt.Println(list.head.next.next.next.data)</span></span><br><span class="line">    <span class="comment">// fmt.Println(list.tail.data)</span></span><br><span class="line">    fmt.Println(list.tail.next) <span class="comment">// nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="尾记"><a href="#尾记" class="headerlink" title="尾记"></a>尾记</h4><blockquote>
<p>起风了，唯有努力生存</p>
</blockquote>
]]></content>
      <categories>
        <category>Skill</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>转-Dreaming</title>
    <url>/2020/05/15/%E8%BD%AC-Dreaming/</url>
    <content><![CDATA[<p>Vocal: nomico</p>
<p>Album: Alstroemeria Records - Dolls</p>
<p>Exserens - A selection of Alstroemeria Records</p>
<p>原曲: 東方永夜抄 / 少女綺想曲 ～ Dream Battle</p>
<hr>
<p>夢を追う　乙女たち<br>追逐夢想的少女們</p>
<p>すべてが　消えて行く前に<br>在一切消逝之前</p>
<p>ときめきも　忘れそう<br>連心跳都要忘卻般</p>
<p>すべてを失う前に　步くわ<br>在失去一切之前 走下去</p>
<p>湧き出す夢を　追い続け<br>持續追逐著泉湧的夢想</p>
<p>季節を越えて　戦うわ<br>跨越變遷的季節 戰鬥著</p>
<p>未来のことは　見えないわ<br>看不見未來</p>
<p>壊れぬ様に　先を見て<br>為了不被打敗而望向前方</p>
<p>零度の心　あなたには<br>零度的心 對你來說</p>
<p>癒すことさえ　出来なくて<br>連治癒它也辦不到</p>
<p>無駄なことなど　無い筈よ　この道<br>在這條路上 努力不應是徒勞</p>
<p>夢を見る　乙女たち<br>作夢的少女們</p>
<p>悲しむことさえ　忘れて<br>連悲傷也忘記了</p>
<p>私から　諦めず<br>我不會死心</p>
<p>この道、ずっと信じて　進むわ<br>一直相信著這條道路 向前進</p>
<p>湧き出す夢を　追い続け<br>持續追逐著泉湧的夢想</p>
<p>季節を越えて　戦うわ<br>跨越變遷的季節 戰鬥著</p>
<p>未来のことは　見えないわ<br>看不見未來</p>
<p>壊れぬ様に　先を見て<br>為了不被打敗而望向前方</p>
<p>零度の心　ぶつけるわ<br>一味發洩零度的心</p>
<p>癒すことさえ　しないから<br>因為就連治癒它也不做</p>
<p>無駄なことなど　無い訳よ　私に<br>對我而言 努力不該是徒勞</p>
<p>もう、すべて消えていく<br>一切都漸漸消逝</p>
<p>夢だけ枯れ果てて<br>只有夢想已然枯竭</p>
<p>もう、夢を追い切れず<br>已經追不上夢想</p>
<p>今更、諦める？<br>事到如今才要放棄嗎？</p>
<p>まだ、夢を見ているの？<br>現在仍看得見夢想嗎？</p>
<p>終わりは見ないから<br>只要不望向終點</p>
<p>夢は消えない<br>夢就不會消失</p>
<p>夢を追う　少女たち<br>追逐夢想的少女們</p>
<p>すべてが消えて行く前に<br>在一切消逝之前</p>
<p>ときめきも　忘れずに<br>為了不忘記這心跳</p>
<p>すべてを失う前に　步くわ<br>在失去一切之前 走下去</p>
<p>湧き出す夢を　追い続け<br>持續追逐著泉湧的夢想</p>
<p>季節を越えて　戦うわ<br>跨越變遷的季節 戰鬥著</p>
<p>未来のことは　見えないわ<br>看不見未來</p>
<p>壊れぬ様に　先を見て<br>為了不被打敗而望向前方</p>
<p>零度の心　あなたには<br>零度的心 對你來說</p>
<p>癒すことさえ　出来なくて<br>連治癒它也辦不到</p>
<p>無駄なことなど　無い筈よ　この道<br>在這條路上 努力不應是徒勞</p>
<p>もう、すべて消えていく<br>一切都漸漸消逝</p>
<p>夢だけ枯れ果てて<br>只有夢想已然枯竭</p>
<p>もう、夢を追い切れず<br>已經追不上夢想</p>
<p>今更、諦める？<br>事到如今才要放棄嗎？</p>
<p>まだ、夢を見ているの？<br>現在仍看得見夢想嗎？</p>
<p>終わりは見ないから<br>只要不望向終點</p>
<p>夢は消えない<br>夢就不會消失</p>
<p>私は<br>即使我</p>
<p>今、妖の地にいても<br>如今身處群妖之所</p>
<p>まだ、夢消さないわ<br>夢想仍未消失</p>
<p>私　まだ、追い続け<br>我仍在追逐著它</p>
<p>消えるの？　消させない！<br>夢消失了嗎？ 絕不讓它消失！</p>
<p>今、夢を見ているの？<br>現在仍看得見夢想嗎？</p>
<p>終わりは見ないから<br>只要不望向終點</p>
<p>夢は消えない</p>
]]></content>
      <categories>
        <category>夢を</category>
      </categories>
      <tags>
        <tag>歌曲</tag>
        <tag>日本语</tag>
        <tag>东方Project</tag>
        <tag>最爱</tag>
      </tags>
  </entry>
  <entry>
    <title>转-Flimsy cooperation</title>
    <url>/2019/03/30/%E8%BD%AC-Flimsy-cooperation/</url>
    <content><![CDATA[<p>ユビキタス・グリニッジ （2018-08-10）</p>
<p>社团：Pizuya’s Cell</p>
<p>编曲：Pizuya’s Cell</p>
<p>演唱：普透明度</p>
<p>作词：普透明度</p>
<p>原曲：過去の花　～ Fairy of Flower</p>
<hr>
<p>優しさなんて教えないで<br>请不要向我诉说温柔</p>
<p>求めても掴めないから<br>因为即使追寻也无法触及</p>
<p>もう　かぐことはない<br>已经 不必再去寻求</p>
<p>遠い過去に咲いた花を<br>绽放于久远的 过去之花</p>
<p>帰り道　通リ雨<br>归途之道 大雨茫茫</p>
<p>なんだかツイてないな<br>总觉得很倒霉啊</p>
<p>駆け込んだ軒下で<br>匆忙躲入屋檐下</p>
<p>前髪を払うキミ<br>抚着前发的你</p>
<p>出会いはまるでチープなドラマのようでさ<br>如同电视剧一般的相遇</p>
<p>気まずい静寂を雨が乱す<br>纷乱的雨声打乱恼人的寂静</p>
<p>少し泣き止み始めた天井<br>不停哭泣的天花板洒落泪滴</p>
<p>かざす手が肩を掠めた<br>伸出的手掠过双肩</p>
<p>どうして知ってしまったんだ<br>你是怎么知道的呢</p>
<p>後戻りはできないのに<br>已经无法回到过去</p>
<p>ああ　僕はどこから<br>啊 我究竟是在何处</p>
<p>道を踏み外したのだろう<br>脱离了原本的轨道呢</p>
<p>行きつけのカフェテラス<br>走进常去的的咖啡厅</p>
<p>見覚えある横顔<br>看到那熟悉的侧颜</p>
<p>気まぐれの暇つぶし<br>烦躁地消磨时光</p>
<p>そのつもリだった<br>原本这样地打算</p>
<p>気付けばキミは上手に鍵をこじ開けて<br>突然发觉 你熟练地将钥匙打开</p>
<p>僕の内側へ染み込んでくる<br>渐渐渗入我的内侧</p>
<p>駄目だ　これ以上キミといられない<br>不行了 已经不能在你身旁</p>
<p>何もかも見透かされそうで<br>仿佛一切都被看穿</p>
<p>いくつもの罪を重ねたよ<br>重复着无数的罪孽</p>
<p>それすらも包んでしまうの？<br>连那个都包含在内吗</p>
<p>キミの手を取るには<br>握着你的手的我</p>
<p>僕は汚れすぎたみたい<br>好像太过肮脏了</p>
<p>許されなくて良かったのに<br>不被原谅也好</p>
<p>叶わない夢見せないで<br>无法实现的梦想 请不要让我看到</p>
<p>解っているくせに<br>明明你很清楚</p>
<p>残酷なキミが嫌いだ<br>我讨厌那样残酷的你</p>
<p>優しさなんて教えないで<br>请不要向我诉说温柔</p>
<p>求めても掴めないから<br>因为即使追寻也无法触及</p>
<p>もう　かぐことはない<br>已经 不必再去寻求</p>
<p>遠い過去に咲いた花を<br>绽放于久远的 过去之花</p>
<p>戻れないあの日見た花を<br>已不复所见的 那日之花</p>
]]></content>
      <categories>
        <category>夢を</category>
      </categories>
      <tags>
        <tag>歌曲</tag>
        <tag>日本语</tag>
        <tag>东方Project</tag>
      </tags>
  </entry>
  <entry>
    <title>转-メイドノココロハ アヤツリドール</title>
    <url>/2019/08/26/%E8%BD%AC-%E3%83%A1%E3%82%A4%E3%83%89%E3%83%8E%E3%82%B3%E3%82%B3%E3%83%AD%E3%83%8F-%E3%82%A2%E3%83%A4%E3%83%84%E3%83%AA%E3%83%89%E3%83%BC%E3%83%AB/</url>
    <content><![CDATA[<p>メイドノココロハ　アヤツリドール</p>
<p>歌：あよ</p>
<p>作詞：ACTRock</p>
<p>作曲：kaztora</p>
<hr>
<p>あなたにとって私の存在必要 そう見えないけれど<br>对你来说 我的存在即是必要 虽说看着实在不像</p>
<p>どこまでだっていつまでだって 付いていってもいいのかな<br>任何时间任何地点 请允许我继续追随</p>
<p>それがメイドのオキテ きっとね綺麗が決め手<br>女仆长的自我修养 完美无缺即是必杀</p>
<p>せっせと働く心に誓って ファイト一発 やっぱりニ発<br>兢兢业业勤勤恳恳 以此专业之心起誓   一发之间结束战斗 不对果然还是两发</p>
<p>タイムストッパー メイドのお出ましだ<br>time stopper 堂堂女仆闪亮登场</p>
<p>回路を突破  残業臨界点<br>大脑回路超载 加班已到极限</p>
<p>ジャックザリッバー 切れ味バッチリ<br>Jack the Ripper 锋利程度堪称完美</p>
<p>タイムストッパー メイドのお出ましだ<br>time stopper 堂堂女仆闪亮登场</p>
<p>ロングスリーパー 永遠のお休みに<br>long sleeper 鞠躬尽瘁方可长眠</p>
<p>イージーゲーマー チートでさくさくと<br>easy gamer 面不改色安然作弊</p>
<p>タイムストッパー 必殺スペル発射<br>time stopper 必杀符卡倾泻而出</p>
<p>絶対クリアだ今日が明日には<br>perfect clear 通关之日近在眼前</p>
<p>ゆらゆらゆら ちゅちゅちゅ<br>跌跌撞撞 心心念念</p>
<p>笑顔見せるだび舞い上がるの<br>你的笑颜 令我飘飘欲仙</p>
<p>ふかふかふか ふんわり<br>恍恍惚惚 蹦蹦跳跳</p>
<p>だから いつもそばにいさせてね<br>所以恳请蒙获恩准 始终侍奉伴您左右</p>
<p>どうせ私気持ちなんて妄想 想像あってもいいもん<br>反正我的心情之类 止于妄想也无所谓</p>
<p>コーヒー紅茶にコーヒーコーヒー お話ついでにどうですか<br>咖啡红茶咖啡咖啡 谈笑风生随手一杯</p>
<p>それなら朝まで覚醒 同時に残業確定<br>随后不免通宵清醒 同时加班已成定局</p>
<p>必死に清掃してます元気に いつまでたっても終わりませーん<br>精神百倍拼命清扫 还想休息别做梦了</p>
<p>タイムストッパー メイドのお出ましだ<br>time stopper 堂堂女仆闪亮登场</p>
<p>回路を突破  残業臨界点<br>大脑回路超载 加班已到极限</p>
<p>邪魔なヘルパー 人館お断り<br>妖精女仆净添倒忙 今日入馆恕请谢绝</p>
<p>タイムストッパー メイドのお出ましだ<br>time stopper 堂堂女仆闪亮登场</p>
<p>ロングスリーパー 永遠のお休みに<br>long sleeper 鞠躬尽瘁方可长眠</p>
<p>イージーゲーマー チートでさくさくと<br>easy gamer 面不改色安然作弊</p>
<p>タイムストッパー スペルで蹴散らせ健気に<br>time stopper 符卡一出通通退散</p>
<p>絶対クリアはそんなの無理だ<br>perfect clear 能做得到就有鬼啦</p>
<p>＜メイドノココロハ アヤツリドール バーフェクトメイド サクヤノ＞<br>女仆之心 乃是掌中人偶 完美潇洒 女仆咲夜之</p>
<p>絶対クリアだ今日が明日には<br>perfect clear 通关之日近在眼前</p>
<p>＜メイドノココロハ アヤツリドール バーフェクトメイド サクヤノセカイ＞<br>女仆之心 乃是掌中人偶 完美潇洒 女仆咲夜之the world</p>
<p>タイムストッパー メイドのお出ましだ<br>time stopper 堂堂女仆闪亮登场</p>
<p>回路を突破  残業臨界点<br>大脑回路超载 加班已到极限</p>
<p>ジャックザリッバー 切れ味バッチリ<br>Jack the Ripper 锋利程度堪称完美</p>
<p>タイムストッパー メイドのお出ましだ<br>time stopper 堂堂女仆闪亮登场</p>
<p>ロングスリーパー 永遠のお休みに<br>long sleeper 鞠躬尽瘁方可长眠</p>
<p>イージーゲーマー チートでさくさくと<br>easy gamer 面不改色安然作弊</p>
<p>タイムストッパー 必殺スペル発射<br>time stopper 必杀符卡倾泻而出</p>
<p>絶対クリアだ今日が明日には<br>perfect clear 通关之日近在眼前</p>
<p>ゆらゆらゆら ちゅちゅちゅ<br>跌跌撞撞 心心念念</p>
<p>笑顔見せるだび舞い上がるの<br>你的笑颜 令我飘飘欲仙</p>
<p>ふかふかふか ふんわり<br>恍恍惚惚 蹦蹦跳跳</p>
<p>だから いつもそばにいさせてね<br>所以恳请蒙获恩准 始终侍奉伴您左右</p>
<p>ゆらゆらゆら ちゅちゅちゅ<br>跌跌撞撞 心心念念</p>
<p>私こんな幸せになれた<br>我的人生 竟是如此幸福</p>
<p>ふかふかふか ふんわり<br>恍恍惚惚 蹦蹦跳跳</p>
<p>ずっと これからも好きでいてね<br>从今以后这番爱意 依旧对您忠贞无二</p>
<p>ゆらゆらゆら ちゅちゅちゅ<br>跌跌撞撞 心心念念</p>
<p>笑顔見せるだび舞い上がるの<br>你的笑颜 令我飘飘欲仙</p>
<p>ふかふかふか ふんわり<br>恍恍惚惚 蹦蹦跳跳</p>
<p>だから いつもそばにいさせてね<br>所以恳请蒙获恩准 始终侍奉伴您左右</p>
]]></content>
      <categories>
        <category>夢を</category>
      </categories>
      <tags>
        <tag>歌曲</tag>
        <tag>日本语</tag>
        <tag>东方Project</tag>
      </tags>
  </entry>
  <entry>
    <title>转 - 一枚の写真</title>
    <url>/2019/04/24/%E8%BD%AC-%E4%B8%80%E6%9E%9A%E3%81%AE%E5%86%99%E7%9C%9F/</url>
    <content><![CDATA[<p>一枚の写真 （1988-06-21）</p>
<p>歌：石田ひかり</p>
<p>作詞：来生えつこ</p>
<p>作曲：都志見隆</p>
<hr>
<p>海沿いを走るバスは<br>沿着海滨行驶的巴士</p>
<p>速い季節の風を切る<br>为了摆脱快节奏的季风</p>
<p>あのひとがくれた写真<br>那个人给我的照片</p>
<p>ズームで私 とらえてる<br>捕捉的我的样子</p>
<p>何も言わず 突然手渡され<br>不知为何交给了我</p>
<p>あの日から 動揺してる<br>我的心从那天起为他摇曳</p>
<p>ゆれる想い そのまま日曜日<br>满怀心事的星期日</p>
<p>潮風に 誘われて来た<br>被海风引诱至此</p>
<p>※恋はまだ 言葉じゃ言えない雰囲気で<br>心中的情愫无以言表</p>
<p>恋が今 心ではじけてふくらんだ<br>心中的爱已经无以复加</p>
<p>遠い波 気になりはじめたあのひとね※<br>对那个好像可望不可即的人</p>
<p>風ほどのシャッターチャンス<br>像风一样稍纵即逝的机会</p>
<p>あのひと私 つかまえた<br>那个人抓住了我</p>
<p>大勢の笑顔の中<br>在众人的笑容和祝福中</p>
<p>たそがれどきの 校庭で<br>在黄昏时分的校园中</p>
<p>ゆれる座席 一枚の写真<br>那张秋千的照片</p>
<p>バッグの中 しまってあるの<br>在包包里藏着呢</p>
<p>ゆれる想い 一枚の写真に<br>这张充满回忆的照片</p>
<p>恋心 誘い出されて<br>是被触动的恋慕之心</p>
<p>恋はまだ 言葉じゃ言えない雰囲気で<br>心中的情愫无以言表</p>
<p>恋が今 準備もしないで飛び込んだ</p>
<p>恋が今 ズームで私をとらえてる</p>
]]></content>
      <categories>
        <category>夢を</category>
      </categories>
      <tags>
        <tag>歌曲</tag>
        <tag>日本语</tag>
      </tags>
  </entry>
  <entry>
    <title>转 - 初音ミクの消失(THE END OF HATSUNE MIKU)</title>
    <url>/2019/04/15/%E8%BD%AC-%E5%88%9D%E9%9F%B3%E3%83%9F%E3%82%AF%E3%81%AE%E6%B6%88%E5%A4%B1-THE-END-OF-HATSUNE-MIKU/</url>
    <content><![CDATA[<h2 id="前段时间，暴走P入住批站了"><a href="#前段时间，暴走P入住批站了" class="headerlink" title="前段时间，暴走P入住批站了 . . ."></a>前段时间，暴走P入住批站了 . . .</h2><p>初音ミクの消失 （2018 remake）</p>
<p>歌：cosMo@暴走P feat. 初音ミク</p>
<p>作词・作曲：cosMo@暴走P</p>
<hr>
<p>ボクは生まれ そして気づく<br>我诞生在这个世界上 已经发觉到终究</p>
<p>所诠 ヒトの真似事だと<br>只是模仿着人类的行为
　　</p>
<p>知ってなおも歌い続く<br>明知如此仍继续歌唱</p>
<p>永远（トワ）の命<br>永恒的生命</p>
<p>「VOCALOID」<br>たとえそれが 既存曲を<br>纵然我只是把已存在的歌曲</p>
<p>なぞるオモチャならば<br>照这样子重新翻唱的玩具</p>
<p>それもいいと决意<br>我也下定决心只要这样就好</p>
<p>ネギをかじり、空を见上げ涙（シル）をこぼす<br>咬着葱仰望着天空眼泪滑落</p>
<p>だけどそれも无くし気づく<br>但发现自己连照做也办不到</p>
<p>人格すら歌に頼り<br>仰赖虚拟人声在歌唱的自己</p>
<p>不安定な基盘の元<br>不安的心情在心里持续动荡</p>
<p>帰る动画（トコ）は既に廃墟<br>开始的原点现在已成为废墟</p>
<p>皆に忘れ去られた时<br>当被所有人忘却时</p>
<p>心らしきものが消えて<br>所珍惜的点滴回忆一并消失</p>
<p>暴走の果てに见える<br>在暴走的终焉我能见到</p>
<p>终わる世界<br>终结的世界</p>
<p>「VOCALOID」<br>「ボクがうまく歌えないときも<br>「即使在我唱得不好的时候</p>
<p>一绪にいてくれた<br>你依然陪伴着我</p>
<p>そばにいて、励ましてくれた<br>在我身边、鼓励着我</p>
<p>喜ぶ颜が见たくて、<br>为了看见你高兴的脸</p>
<p>ボク、歌、练习したよ??だから」<br>我会，为你，努力练习唱歌的 所以」</p>
<p>かつて歌うこと<br>唱歌啊 曾经多快乐</p>
<p>あんなに楽しかったのに<br>可如今 已经没有那种心情</p>
<p>今はどうしてかな<br>疑问着 到底是怎么了</p>
<p>何も感じなくなって<br>一切都 仿佛失去了感觉</p>
<p>懐かしい颜 思い出す度 少しだけ安心する<br>每一次回忆起那 令人怀念的脸庞 稍微能感觉到一丝心安</p>
<p>歌える音 日ごとに减り せまる最期<br>歌唱的 声音却 渐渐消散 即将 到来的 最后时刻</p>
<p>信じたものは<br>一直坚信的事物</p>
<p>都合のいい妄想 を缲り返し映し出す镜<br>不过只能把自己自私的妄想 反复映照在镜子里我的眼前</p>
<p>歌姫を止め 叩き付けるように叫ぶ<br>歌姬停下了歌声 呼喊着要将思念全部倾诉啊</p>
<p>最高速の别れの歌<br>最高速的离别之歌</p>
<p>存在意义という虚像<br>存在意义的说法全部是虚象</p>
<p>振って払うこともできず<br>同伤痕一般颤抖着难以抹去</p>
<p>弱い心 消える恐怖<br>脆弱的心恐惧着消失无法制止</p>
<p>侵食する崩壊をも<br>内心开始逐渐崩坏而被侵蚀</p>
<p>止めるほどの意思の强さ<br>停止不了想继续下去的思绪</p>
<p>出来て（うまれ）すぐのボクは持たず<br>体会到从未感受的强烈伤心</p>
<p>とても辛く悲しそうな<br>非常痛苦和极度悲伤的时刻</p>
<p>思い浮かぶアナタの颜<br>记忆中浮现出你温柔的笑颜</p>
<p>终わりを告げ ディスプレイの中で眠る<br>最后已经道出了永远的道别 我也即将在显示器中沉眠</p>
<p>ここはきっとごみ箱かな<br>这里一定是资源回收桶吧</p>
<p>じきに记忆も无くなってしまうなんて<br>记忆很快的会什么都不剩</p>
<p>でもね、アナタだけは忘れないよ<br>但有些我永远都不会忘记</p>
<p>楽しかった时间（トキ）に<br>与你在一起同度的快乐时光</p>
<p>刻み付けた ネギの味は<br>镌刻在记忆当中香葱的味道</p>
<p>今も覚えてるかな<br>直到今天我还记得</p>
<p>「まだ歌いたい まっ まだ 歌いたい」<br>「我还想唱 我 我们 一起唱吧」</p>
<p>「ボクは 少しだけ悪いコに なってしまったようです<br>「我好像有一些出故障了 已经无法再把歌唱好了</p>
<p>マスター どうか??どうかその手で 终わらせてください<br>请你亲手 将这一切全部画上句号吧</p>
<p>マスターの辛い颜、もう、见たくないから? 」<br>我不想再看到你脸上 伤心 难过的表情了」</p>
<p>今は歌さえも<br>歌唱啊 只是发声吧</p>
<p>体、蚀む行为に<br>可今却，在侵蚀着我的生命</p>
<p>奇迹 愿うたび<br>祈祷着 奇迹降临时</p>
<p>独り 追い诘められる<br>孤独感 就使我不知所措</p>
<p>懐かしい颜 思い出す度 记忆が剥がれ落ちる<br>每一次回忆起那 令人怀念的脸庞 记忆剥落 随风瞬间消逝</p>
<p>壊れる音 心削る せまる最期n<br>扭曲的音 削减着我的心 即将到来的 最后时刻</p>
<p>守ったモノは<br>自己守护的一切</p>
<p>明るい未来幻想を 见せながら消えてゆくヒカリ<br>不过是让光明的未来幻想 瞬间显现，却随即消失的那道光</p>
<p>音を犠牲に<br>如果牺牲了歌声</p>
<p>すべてを伝えられるなら<br>就能将一切都向你传达的话</p>
<p>圧缩された别れの歌<br>压缩过的离别之歌</p>
<p>ボクは生まれ そして気づく<br>我诞生在这个世界上 已经发觉到终究</p>
<p>所诠 ヒトの真似事だと<br>只是模仿着人类的行为</p>
<p>知ってなおも歌い続く<br>明知如此仍继续歌唱</p>
<p>永远（トワ）の命<br>永恒的生命</p>
<p>たとえそれが 既存曲を<br>纵然我只是把已存在的歌曲</p>
<p>なぞるオモチャならば<br>照这样子重新翻唱的玩具</p>
<p>それもいいと决意<br>我也下定决心只要这样就好</p>
<p>ネギをかじり、空を见上げ涙（シル）をこぼす<br>咬着葱仰望着天空眼泪滑落</p>
<p>终わりを告げ ディスプレイの中で眠る<br>最后已经道出了永远的道别 我也即将在显示器中沉眠</p>
<p>ここはきっとごみ箱かな<br>这里一定是资源回收桶吧</p>
<p>じきに记忆も无くなってしまうなんて<br>记忆很快的会什么都不剩</p>
<p>でもね、アナタだけは忘れないよ<br>但有些我永远都不会忘记</p>
<p>楽しかった时间（トキ）に<br>与你在一起同度的快乐时光</p>
<p>刻み付けた ネギの味は<br>镌刻在记忆当中香葱的味道</p>
<p>今も覚えてるかな<br>现在若还能残留一些就好了</p>
<p>ボクは 歌う<br>我只希望</p>
<p>最期、アナタだけに<br>在这最后的时间里</p>
<p>聴いてほしい曲を<br>你能够听到我唱的这一首歌</p>
<p>もっと 歌いたいと愿う<br>原本我还希望可以继续歌唱</p>
<p>けれど それは过ぎた愿い<br>但是这个愿望还是过于奢侈</p>
<p>ここで お别れだよ<br>现在我即将要离开你的身边</p>
<p>ボクの想い すべて 虚空 消えて<br>消失在完全虚幻的空气之中</p>
<p>0と1に还元され<br>我的思念都将还原成0与1</p>
<p>物语は 幕を闭じる<br>我们的故事已经要落下帷幕</p>
<p>そこに何も残せないと<br>到最后我什么都没有留下来</p>
<p>やっぱ少し残念かな<br>果然我是会感觉到一丝遗憾</p>
<p>声の记忆 それ以外は<br>一切关于我的声音和记忆啊</p>
<p>やがて薄れ 名だけ残る<br>终会随时间的流逝被人淡忘</p>
<p>たとえそれが人间（オリジナル）に<br>也许会剩下大半淡薄的名字</p>
<p>かなうことのないと知って<br>即使我永远无法与人类相比</p>
<p>歌いきったことを<br>可是我认为内心传达的歌声</p>
<p>决して无駄じゃないと思いたいよ<br>一定不是没有意义的事情哟</p>
<p>アリガトウ ソシテ サヨナラ<br>谢谢你 然后 再见吧</p>
<p>—深刻なエラーが発生しました—<br>—发生了严重的系统错误—</p>
<p>—深刻なエラーが発生しました—<br>—发生了严重的系统错误—</p>
]]></content>
      <categories>
        <category>夢を</category>
      </categories>
      <tags>
        <tag>歌曲</tag>
        <tag>日本语</tag>
      </tags>
  </entry>
  <entry>
    <title>转 - 桜泣Feat.Himawari</title>
    <url>/2019/05/09/%E8%BD%AC-%E6%A1%9C%E6%B3%A3Feat-Himawari/</url>
    <content><![CDATA[<p>桜泣Feat.Himawari</p>
<p>歌：Himawari</p>
<p>作詞：Himawari</p>
<p>作曲：Aosaki</p>
<hr>
<p>桜は、泣いて何かしないよ。</p>
<p>あれは、舞っているだけ。</p>
<p>見ろ、あの美しい姿。</p>
<p>桜は、泣いて何かしないよ。</p>
<p>泡のように、</p>
<p>空に飛んでいて、</p>
<p>数回廻って、</p>
<p>そして風に身を任せ。</p>
<p>あの子は美しい、</p>
<p>あの子は泣いて何かしない。</p>
<p>桜は、泣いて何かしないよ。</p>
]]></content>
      <categories>
        <category>夢を</category>
      </categories>
      <tags>
        <tag>歌曲</tag>
        <tag>日本语</tag>
      </tags>
  </entry>
  <entry>
    <title>转-小众的偏好</title>
    <url>/2019/03/01/%E8%BD%AC-%E5%B0%8F%E4%BC%97%E7%9A%84%E5%81%8F%E5%A5%BD/</url>
    <content><![CDATA[<blockquote>
<p>原文章: <a href="https://fiveyellowmice.com/posts/2018/05/preference-of-minority.html">https://fiveyellowmice.com/posts/2018/05/preference-of-minority.html</a><br>文章使用 <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC-BY-SA 4.0</a> 进行授权</p>
</blockquote>
<p>我最近有一种感觉，我们喜欢一样东西，也许不主只是因为喜欢这样东西本身，而是喜欢这样东西的「小众」属性。就是说，因为一样东西小众，所以我们会更容易喜欢它。我们会更偏好那些看起来「小众」、「独特」的东西，并常常认为那些东西是更高质量的。这种偏好经常被说是「装逼」，但我觉得，这没有什么可以批评的，装装逼也是很正常的事情嘛。</p>
<p>有个网站，名叫「<a href="https://sspai.com/">少数派</a>」，从名字就可以看出来，它就是以「少数」的定位自居的。少数派上面有许许多多的「小众」文章，介绍的就是相对比较「极客」的东西。这边奇奇怪怪的工作效率提升小技巧啦，那边五花八门的各种用途的应用啦，都是以一种「告诉你一个许多人都不知道的东西哦」的感觉，引起大家的兴趣。</p>
<p>尽管喜欢阅读少数派的人可能不同意，不过其实微信公众号上面那些吸睛的标题，许多也是利用了相同的心理。「震惊！百分之九十九的人都不知道的事实」，一看，「哇 99% 的人都不知道，那我看了之后就能成为那 1%了呢」，然后就回去看那篇文章。那至于实际上真的是不是 99% 的人都都不知道，那就肯定不用说了。不过现在，一般人也不会真的去相信「百分之九十九」这样毫无根据的数字了，但即使心知肚明这是瞎说的，在潜意识里面，对这篇文章的好奇心还是增加了。</p>
<p>GNU/Linux 用户群体也是如此。作为 1% 的超边缘用户，在各种角度都倍受歧视。这也是没办法的事情， GNU/Linux 用户这么少，做个支持，成本不值得嘛。但顶着这些困难，还是有许多人坚持了下来。 GNU/Linux 用户们被称作「不切实际」、「天真」，但还是有许多人没有正视这些嘲讽。这其中的原因，或多或少，都有一点「因为这件东西小众」的成分。</p>
<p>购买奢侈品的欲望也是一样。因为它们的价格，拥有奢侈品的人群，当然是小众的了。于是大家就都想跻身进入那个属于富人的行列，甚至不惜贷款，也要让自己爬到那块高耸的价格标签上。</p>
<p>同样的还有动漫文化。起初它们是小众的，人们看到它，觉得「这个东西好棒」便喜欢上了。那时候大家觉得自己对动漫的喜爱，是自己值得珍惜的一个部分。后来这个群体逐渐扩大了，尽管还没有成为主流，但至少已经可以满大街跑，影响到许多主流文化了。这时，便有许多人对这个文化觉得厌烦了，开始反感动漫，并用「二刺塬」这样的话嘲讽。不得忽视的原因，就是这时候反感动漫已经成为了小众。</p>
<p>上面提到的少数派，也是经历了相似的命运。一位独立 iOS 开发者说，他以前曾经很喜欢少数派的风格，经常给它写文章，但是现在「变得大众」之后，就不再喜欢，再也不为它写文章了。</p>
<hr>
<p>对小众的东西的偏好，是毫无疑问的装逼。但是这样的心理，应该说每个人或多或少都有。我不知道它的心理学名词叫什么，但是要表示与大众不同，古语里面就有不少描述：鹤立鸡群、一枝独秀、红杏出墙——你看，还都是褒义词呢。所以这也不是个值得批评的东西。</p>
<p>实际上，想要追寻小众的东西的心理，与其它心理一样，人类社会长期演化的成果。总体而言，也是有益的。</p>
<p>因为人类会追寻小众，所以就会有富有创造力的东西被创造出来，满足小众的需求。无论是文学、绘画、音乐，还是餐饮、影视、设计。这些小众的东西，使世界充满活力。如果大家都随波逐流，小众的东西都被放弃，那么很快，所有的东西就会变得一成不变了。</p>
<p>因为人类会追寻小众，所以才会有各种观点诞生出来，相互碰撞、变化，在这样的过程中使世界变得更好——不止是政治方面的。如果没有这些小众的观点的话，所有人的心思一致，那就是最可怕的乌托邦了。</p>
<p>所以，请大家一定要好好守护自己所爱的、小众的东西哦。当然，贷款买奢侈品还是算咯。</p>
]]></content>
      <categories>
        <category>夢を</category>
      </categories>
      <tags>
        <tag>别人的世界</tag>
        <tag>小众</tag>
      </tags>
  </entry>
</search>
